<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Shell | Aurélien Loyer</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <meta name="description" content="Détails du projet Mini Shell d'Aurélien Loyer, un shell simplifié en langage C.">
    <style>
        .terminal-container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-header {
            background-color: #333;
            padding: 8px 12px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: -10px -10px 10px -10px;
        }
        
        .terminal-title {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .terminal-buttons {
            display: flex;
        }
        
        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .button-red {
            background-color: #ff5f56;
        }
        
        .button-yellow {
            background-color: #ffbd2e;
        }
        
        .button-green {
            background-color: #27c93f;
        }
        
        .terminal-content {
            color: #f8f8f2;
            white-space: pre-wrap;
            line-height: 1.5;
            min-height: 280px;
        }
        
        .terminal-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .terminal-prompt {
            color: #50fa7b;
            margin-right: 8px;
        }
        
        .terminal-command {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
        }

        .light-theme .terminal-container {
            background-color: #2a2a2a;
        }
        
        .light-theme .terminal-header {
            background-color: #444;
        }
        
        .light-theme .terminal-content,
        .light-theme .terminal-command {
            color: #e6e6e6;
        }
        
        .try-it-button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #50fa7b;
            color: #1e1e1e;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .try-it-button:hover {
            background-color: #2ebd5a;
        }
        
        .light-theme .try-it-button {
            background-color: #2ebd5a;
            color: #fff;
        }
        
        .light-theme .try-it-button:hover {
            background-color: #1a9043;
        }

        /* Ajout pour le terminal interactif */
        .interactive-prompt {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        #commandInput {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
            caret-color: #f8f8f2;
        }

        .light-theme #commandInput {
            color: #e6e6e6;
            caret-color: #e6e6e6;
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrapper">
        <div class="loader">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <!-- Navbar -->
    <nav class="navbar" id="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">AL<span class="dot">.</span></a>
            </div>
            <div class="nav-menu">
                <ul class="nav-links">
                    <li><a href="index.html#home" class="nav-link">Accueil</a></li>
                    <li><a href="index.html#about" class="nav-link">À propos</a></li>
                    <li><a href="index.html#skills" class="nav-link">Compétences</a></li>
                    <li><a href="index.html#projects" class="nav-link active">Projets</a></li>
                    <li><a href="index.html#contact" class="nav-link">Contact</a></li>
                </ul>
                <div class="nav-actions">
                    <button class="theme-toggle" id="theme-toggle" aria-label="Changer de thème">
                        <i class="fas fa-moon"></i>
                    </button>
                    <a href="cv_loyeraurelien.pdf" class="btn btn-outline" target="_blank">
                        <i class="fas fa-file-alt"></i> Mon CV
                    </a>
                </div>
            </div>
            <div class="hamburger" id="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- Project Header -->
    <section class="project-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="index.html">Accueil</a> / 
                <a href="index.html#projects">Projets</a> / 
                <span>Mini Shell</span>
            </div>
            <h1 class="project-title">Mini Shell</h1>
            <div class="project-meta">
                <div class="meta-item">
                    <i class="fas fa-calendar-alt"></i>
                    <span>2024</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-code"></i>
                    <span>C</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-terminal"></i>
                    <span>Shell</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Project Content -->
    <section class="project-content">
        <div class="container">
            <div class="project-details">
                <div class="project-demo">
                    <h2>Démonstration</h2>
                    <div class="video-container">
                        <video controls>
                            <source src="videos/mini_shell_demo.mp4" type="video/mp4">
                            Votre navigateur ne supporte pas la lecture de vidéos.
                        </video>
                    </div>
                </div>

                <div class="project-overview">
                    <h2>Aperçu du projet</h2>
                    <p>
                        Mini Shell est un interpréteur de commandes simplifié développé en langage C. Ce projet avait pour objectif de créer un terminal capable d'exécuter des commandes de base du système Unix et de gérer différentes fonctionnalités intégrées (builtins).
                    </p>
                </div>

                <div class="project-features">
                    <h2>Fonctionnalités</h2>
                    <ul>
                        <li><i class="fas fa-check-circle"></i> Exécution de commandes externes (ls, cat, grep, etc.)</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des commandes intégrées (cd, exit, env, setenv, unsetenv)</li>
                        <li><i class="fas fa-check-circle"></i> Support des variables d'environnement</li>
                        <li><i class="fas fa-check-circle"></i> Gestion du changement de répertoire</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des erreurs et des exceptions</li>
                    </ul>
                </div>

                <div class="project-technical">
                    <h2>Aspects techniques</h2>
                    <p>
                        Ce shell a été implémenté en C, en utilisant diverses fonctions système comme fork(), execve(), waitpid() pour la gestion des processus enfants. L'environnement système est géré à travers une structure de données personnalisée permettant la manipulation des variables d'environnement.
                    </p>
                    
                    <h3>Essayez Mini Shell (en très très simplifié ...) en direct!</h3>
                    
                    <div class="terminal-container" id="terminalContainer">
                        <div class="terminal-header">
                            <div class="terminal-buttons">
                                <div class="terminal-button button-red"></div>
                                <div class="terminal-button button-yellow"></div>
                                <div class="terminal-button button-green"></div>
                            </div>
                            <div class="terminal-title">Terminal - Mini Shell</div>
                            <div style="width: 50px;"></div>
                        </div>
                        <div class="terminal-content" id="terminalContent">Prêt à exécuter Mini Shell...</div>
                        <div class="interactive-prompt" id="promptContainer" style="display: none;">
                            <span class="terminal-prompt" id="prompt">$</span>
                            <input type="text" id="commandInput" autocomplete="off" spellcheck="false">
                        </div>
                    </div>
                    
                    <button class="try-it-button" id="launchShellBtn">
                        <i class="fas fa-terminal"></i> Lancer mysh
                    </button>
                </div>

                <div class="project-challenges">
                    <h2>
                    Défis et solutions</h2>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Gestion des processus</h3>
                        <p>
                            Un des principaux défis était la gestion correcte des processus enfants pour éviter les fuites de mémoire et les processus zombies. J'ai résolu ce problème en implémentant un système robuste de suivi des processus avec waitpid().
                        </p>
                    </div>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Manipulation de l'environnement</h3>
                        <p>
                            La gestion des variables d'environnement nécessitait une attention particulière, notamment pour les commandes setenv et unsetenv. J'ai développé une structure de données dédiée pour faciliter ces opérations.
                        </p>
                    </div>
                </div>

                <div class="project-learnings">
                    <h2>Ce que j'ai appris</h2>
                    <p>
                        Ce projet m'a permis d'approfondir mes connaissances sur:
                    </p>
                    <ul>
                        <li>Le fonctionnement interne des shells Unix</li>
                        <li>La gestion des processus en C</li>
                        <li>Les appels système Linux/Unix</li>
                        <li>La manipulation avancée de chaînes de caractères</li>
                        <li>La gestion efficace de la mémoire</li>
                    </ul>
                </div>

                <div class="project-links">
                    <h2>Liens</h2>
                    <a href="https://github.com/aurelien-loyer/mini_shell" class="btn btn-primary" target="_blank">
                        <i class="fab fa-github"></i> Code source
                    </a>
                </div>
            </div>

            <div class="other-projects">
                <h2>Autres projets</h2>
                <div class="projects-grid small-grid">
                    <div class="project-card" data-category="csfml">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">My Radar</h3>
                            <p class="project-description">Simulateur de contrôle aérien avec CSFML</p>
                            <a href="my_radar.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="c">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">Organized</h3>
                            <p class="project-description">Programme d'organisation de données</p>
                            <a href="organized.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="python">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">105demography</h3>
                            <p class="project-description">Analyse démographique en Python</p>
                            <a href="105demography.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <a href="index.html">AL<span class="dot">.</span></a>
                    <p>Développeur passionné</p>
                </div>
                
                <div class="footer-links">
                    <h3>Liens rapides</h3>
                    <ul>
                        <li><a href="index.html#home">Accueil</a></li>
                        <li><a href="index.html#about">À propos</a></li>
                        <li><a href="index.html#skills">Compétences</a></li>
                        <li><a href="index.html#projects">Projets</a></li>
                        <li><a href="index.html#contact">Contact</a></li>
                    </ul>
                </div>
                
                <div class="footer-social">
                    <h3>Me suivre</h3>
                    <div class="social-icons">
                        <a href="https://github.com/aurelien-loyer" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/aurelien-loyer-epi/" target="_blank">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="mailto:aurelien.loyer@epitech.eu">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>© 2025 Aurélien Loyer. Tous droits réservés.</p>
                <a href="#" class="back-to-top">
                    <i class="fas fa-arrow-up"></i>
                </a>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script>
        // Variables pour le terminal interactif
const terminalContent = document.getElementById('terminalContent');
const launchShellBtn = document.getElementById('launchShellBtn');
const promptContainer = document.getElementById('promptContainer');
const commandInput = document.getElementById('commandInput');
const prompt = document.getElementById('prompt');

// État du shell
let shellRunning = false;
let currentDirectory = "~/mysh";
let envVariables = {
    "HOME": "~/mysh",
    "PATH": "/usr/local/bin:/usr/bin:/bin",
    "USER": "user",
    "PWD": "~/mysh",
    "SHELL": "~/mysh/mysh",
    "TERM": "xterm-256color",
    "LANG": "en_US.UTF-8"
};

// Structure de fichiers simulée - Ajout de plus de fichiers et de contenu
const fileSystem = {
    "~/mysh": {
        type: "directory",
        contents: {
            "README.md": {
                type: "file",
                content: "# Mini Shell\n\nShell simplifié en langage C\n\n## Compilation\n\n```\nmake\n```\n\n## Utilisation\n\n```\n./mysh\n```\n\n## Fonctionnalités\n\n- Exécution de commandes\n- Gestion des variables d'environnement\n- Commandes internes: cd, env, setenv, unsetenv, exit\n- Gestion du PATH\n- Redirections basiques\n- Pipes simples"
            },
            ".myshrc": {
                type: "file",
                content: "# Configuration du Mini Shell\n\n# Aliases\nalias ll='ls -l'\nalias la='ls -la'\nalias c='clear'\n\n# Variables d'environnement\nPS1=\"\\u@\\h:\\w$ \"\nPATH=\"$PATH:/usr/local/sbin\"\n\n# Message de bienvenue\necho \"Bienvenue dans Mini Shell!\""
            },
            "src": {
                type: "directory",
                contents: {
                    "main.c": {
                        type: "file",
                        content: "#include \"../include/mysh.h\"\n\nint main(int argc, char **argv, char **env) {\n    // Initialize environment\n    char **env_copy = copy_environment(env);\n    \n    // Initialize shell data\n    shell_t shell;\n    init_shell(&shell, env_copy);\n    \n    // Start command loop\n    run_shell(&shell);\n    \n    // Clean up before exit\n    free_environment(env_copy);\n    cleanup_shell(&shell);\n    return 0;\n}"
                    },
                    "builtins.c": {
                        type: "file",
                        content: "#include \"../include/builtins.h\"\n\nint is_builtin(const char *command) {\n    static const char *builtins[] = {\n        \"cd\", \"exit\", \"env\", \"setenv\", \"unsetenv\", \"echo\", NULL\n    };\n    \n    for (int i = 0; builtins[i] != NULL; i++) {\n        if (strcmp(command, builtins[i]) == 0)\n            return 1;\n    }\n    \n    return 0;\n}\n\nvoid execute_builtin(char **args, shell_t *shell) {\n    if (strcmp(args[0], \"cd\") == 0) {\n        builtin_cd(args, shell);\n    } else if (strcmp(args[0], \"exit\") == 0) {\n        builtin_exit(args, shell);\n    } else if (strcmp(args[0], \"env\") == 0) {\n        builtin_env(args, shell);\n    } else if (strcmp(args[0], \"setenv\") == 0) {\n        builtin_setenv(args, shell);\n    } else if (strcmp(args[0], \"unsetenv\") == 0) {\n        builtin_unsetenv(args, shell);\n    } else if (strcmp(args[0], \"echo\") == 0) {\n        builtin_echo(args, shell);\n    }\n}\n\nvoid builtin_cd(char **args, shell_t *shell) {\n    char *target_dir;\n    char current_dir[PATH_MAX];\n    \n    if (args[1] == NULL || strcmp(args[1], \"~\") == 0) {\n        target_dir = get_env_value(shell->env, \"HOME\");\n    } else {\n        target_dir = args[1];\n    }\n    \n    if (chdir(target_dir) != 0) {\n        fprintf(stderr, \"cd: %s: No such file or directory\\n\", target_dir);\n        shell->last_status = 1;\n        return;\n    }\n    \n    // Update PWD environment variable\n    if (getcwd(current_dir, PATH_MAX) != NULL) {\n        set_env_value(&shell->env, \"PWD\", current_dir);\n        shell->last_status = 0;\n    }\n}"
                    },
                    "execute.c": {
                        type: "file",
                        content: "#include \"../include/mysh.h\"\n\nvoid execute_command(char *command, shell_t *shell) {\n    // Parse command\n    command_t cmd;\n    if (parse_command(command, &cmd) != 0) {\n        fprintf(stderr, \"Invalid command syntax\\n\");\n        shell->last_status = 1;\n        return;\n    }\n    \n    // Check if builtin\n    if (is_builtin(cmd.args[0])) {\n        execute_builtin(cmd.args, shell);\n        free_command(&cmd);\n        return;\n    }\n    \n    // Check for pipes\n    if (cmd.pipe_cmd != NULL) {\n        execute_pipeline(&cmd, shell);\n        free_command(&cmd);\n        return;\n    }\n    \n    // Regular command execution\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        \n        // Handle redirections\n        setup_redirections(&cmd);\n        \n        // Search in PATH if needed\n        char *cmd_path = find_command_in_path(cmd.args[0], shell->env);\n        if (cmd_path == NULL) {\n            fprintf(stderr, \"%s: Command not found\\n\", cmd.args[0]);\n            exit(1);\n        }\n        \n        execve(cmd_path, cmd.args, shell->env);\n        perror(\"execve\");\n        free(cmd_path);\n        exit(1);\n    } else if (pid > 0) {\n        // Parent process\n        int status;\n        waitpid(pid, &status, 0);\n        shell->last_status = WEXITSTATUS(status);\n    } else {\n        perror(\"fork\");\n        shell->last_status = 1;\n    }\n    \n    free_command(&cmd);\n}"
                    },
                    "env_manager.c": {
                        type: "file",
                        content: "#include \"../include/env_manager.h\"\n\nchar **copy_environment(char **env) {\n    int count = 0;\n    while (env[count] != NULL)\n        count++;\n    \n    char **env_copy = malloc(sizeof(char *) * (count + 1));\n    if (env_copy == NULL) {\n        fprintf(stderr, \"Memory allocation error\\n\");\n        exit(1);\n    }\n    \n    for (int i = 0; i < count; i++)\n        env_copy[i] = strdup(env[i]);\n    env_copy[count] = NULL;\n    \n    return env_copy;\n}\n\nvoid free_environment(char **env) {\n    if (env == NULL)\n        return;\n    \n    for (int i = 0; env[i] != NULL; i++)\n        free(env[i]);\n    free(env);\n}\n\nchar *get_env_value(char **env, const char *name) {\n    int name_len = strlen(name);\n    \n    for (int i = 0; env[i] != NULL; i++) {\n        if (strncmp(env[i], name, name_len) == 0 && env[i][name_len] == '=') {\n            return &env[i][name_len + 1];\n        }\n    }\n    \n    return NULL;\n}\n\nvoid set_env_value(char ***env_ptr, const char *name, const char *value) {\n    char **env = *env_ptr;\n    int name_len = strlen(name);\n    int i;\n    \n    // Check if already exists\n    for (i = 0; env[i] != NULL; i++) {\n        if (strncmp(env[i], name, name_len) == 0 && env[i][name_len] == '=') {\n            // Update existing value\n            free(env[i]);\n            env[i] = malloc(name_len + strlen(value) + 2);\n            sprintf(env[i], \"%s=%s\", name, value);\n            return;\n        }\n    }\n    \n    // Add new value\n    int env_size = i + 2; // +1 for new entry, +1 for NULL terminator\n    char **new_env = realloc(env, sizeof(char *) * env_size);\n    if (new_env == NULL) {\n        fprintf(stderr, \"Memory allocation error\\n\");\n        return;\n    }\n    \n    new_env[i] = malloc(name_len + strlen(value) + 2);\n    sprintf(new_env[i], \"%s=%s\", name, value);\n    new_env[i + 1] = NULL;\n    \n    *env_ptr = new_env;\n}"
                    },
                    "parser.c": {
                        type: "file",
                        content: "#include \"../include/parser.h\"\n\nint parse_command(char *input, command_t *cmd) {\n    memset(cmd, 0, sizeof(command_t));\n    \n    // Remove trailing newline\n    int len = strlen(input);\n    if (len > 0 && input[len - 1] == '\\n') {\n        input[len - 1] = '\\0';\n        len--;\n    }\n    \n    // Handle empty command\n    if (len == 0) {\n        cmd->args[0] = NULL;\n        return 0;\n    }\n    \n    // Check for pipe\n    char *pipe_pos = strchr(input, '|');\n    if (pipe_pos != NULL) {\n        *pipe_pos = '\\0';\n        cmd->pipe_cmd = malloc(sizeof(command_t));\n        if (cmd->pipe_cmd == NULL) {\n            fprintf(stderr, \"Memory allocation error\\n\");\n            return 1;\n        }\n        return parse_command(pipe_pos + 1, cmd->pipe_cmd);\n    }\n    \n    // Check for redirections\n    check_redirections(input, cmd);\n    \n    // Tokenize\n    return tokenize_command(input, cmd);\n}\n\nint tokenize_command(char *input, command_t *cmd) {\n    char *token;\n    int i = 0;\n    \n    token = strtok(input, \" \\t\");\n    while (token != NULL && i < MAX_ARGS - 1) {\n        // Handle variable expansion\n        if (token[0] == '$') {\n            // Implement variable expansion logic\n        }\n        \n        cmd->args[i++] = strdup(token);\n        token = strtok(NULL, \" \\t\");\n    }\n    \n    cmd->args[i] = NULL;\n    return 0;\n}\n\nvoid check_redirections(char *input, command_t *cmd) {\n    // Implement redirection parsing\n    // e.g., > output_file, < input_file, >> append_file\n}\n\nvoid free_command(command_t *cmd) {\n    if (cmd == NULL)\n        return;\n    \n    for (int i = 0; cmd->args[i] != NULL; i++)\n        free(cmd->args[i]);\n    \n    if (cmd->input_file)\n        free(cmd->input_file);\n    if (cmd->output_file)\n        free(cmd->output_file);\n    if (cmd->pipe_cmd) {\n        free_command(cmd->pipe_cmd);\n        free(cmd->pipe_cmd);\n    }\n}"
                    },
                    "utils.c": {
                        type: "file",
                        content: "#include \"../include/mysh.h\"\n\nchar *find_command_in_path(const char *command, char **env) {\n    // If command contains '/', it's a direct path\n    if (strchr(command, '/') != NULL) {\n        return strdup(command);\n    }\n    \n    // Get PATH environment variable\n    char *path_env = get_env_value(env, \"PATH\");\n    if (path_env == NULL) {\n        return NULL;\n    }\n    \n    // Make a copy since strtok modifies the string\n    char *path_copy = strdup(path_env);\n    char *path;\n    char full_path[PATH_MAX];\n    char *result = NULL;\n    \n    // Search in each directory in PATH\n    path = strtok(path_copy, \":\");\n    while (path != NULL) {\n        snprintf(full_path, PATH_MAX, \"%s/%s\", path, command);\n        \n        // Check if file exists and is executable\n        if (access(full_path, X_OK) == 0) {\n            result = strdup(full_path);\n            break;\n        }\n        \n        path = strtok(NULL, \":\");\n    }\n    \n    free(path_copy);\n    return result;\n}\n\nvoid init_shell(shell_t *shell, char **env) {\n    shell->env = env;\n    shell->last_status = 0;\n    shell->running = 1;\n    shell->interactive = isatty(STDIN_FILENO);\n    \n    // Set up signal handlers\n    setup_signals();\n    \n    // Load configuration files if interactive\n    if (shell->interactive) {\n        load_rc_file(shell);\n    }\n}\n\nvoid run_shell(shell_t *shell) {\n    char input[MAX_INPUT_SIZE];\n    \n    while (shell->running) {\n        // Display prompt if interactive\n        if (shell->interactive) {\n            display_prompt(shell);\n        }\n        \n        // Read input\n        if (fgets(input, MAX_INPUT_SIZE, stdin) == NULL) {\n            if (feof(stdin)) {\n                printf(\"exit\\n\");\n                break;\n            }\n            continue;\n        }\n        \n        // Execute command\n        execute_command(input, shell);\n    }\n}\n\nvoid cleanup_shell(shell_t *shell) {\n    // Any cleanup needed\n}\n\nvoid setup_signals(void) {\n    // Set up signal handlers\n    signal(SIGINT, signal_handler);\n}\n\nvoid signal_handler(int signum) {\n    if (signum == SIGINT) {\n        printf(\"\\n\");\n    }\n}"
                    }
                }
            },
            "include": {
                type: "directory",
                contents: {
                    "mysh.h": {
                        type: "file",
                        content: "#ifndef MYSH_H\n#define MYSH_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <signal.h>\n\n#include \"builtins.h\"\n#include \"env_manager.h\"\n#include \"parser.h\"\n\n#define MAX_INPUT_SIZE 4096\n\n// Shell state structure\ntypedef struct shell_s {\n    char **env;\n    int last_status;\n    int running;\n    int interactive;\n} shell_t;\n\n// Function prototypes\nvoid init_shell(shell_t *shell, char **env);\nvoid run_shell(shell_t *shell);\nvoid cleanup_shell(shell_t *shell);\nvoid execute_command(char *command, shell_t *shell);\nchar *find_command_in_path(const char *command, char **env);\nvoid setup_signals(void);\nvoid signal_handler(int signum);\nvoid display_prompt(shell_t *shell);\nvoid load_rc_file(shell_t *shell);\nvoid execute_pipeline(command_t *cmd, shell_t *shell);\n\n#endif"
                    },
                    "builtins.h": {
                        type: "file",
                        content: "#ifndef BUILTINS_H\n#define BUILTINS_H\n\n#include \"mysh.h\"\n\n// Forward declaration for shell_t\nstruct shell_s;\ntypedef struct shell_s shell_t;\n\n// Builtin commands\nint is_builtin(const char *command);\nvoid execute_builtin(char **args, shell_t *shell);\nvoid builtin_cd(char **args, shell_t *shell);\nvoid builtin_exit(char **args, shell_t *shell);\nvoid builtin_env(char **args, shell_t *shell);\nvoid builtin_setenv(char **args, shell_t *shell);\nvoid builtin_unsetenv(char **args, shell_t *shell);\nvoid builtin_echo(char **args, shell_t *shell);\n\n#endif"
                    },
                    "env_manager.h": {
                        type: "file",
                        content: "#ifndef ENV_MANAGER_H\n#define ENV_MANAGER_H\n\n#include \"mysh.h\"\n\n// Environment variable functions\nchar **copy_environment(char **env);\nvoid free_environment(char **env);\nchar *get_env_value(char **env, const char *name);\nvoid set_env_value(char ***env_ptr, const char *name, const char *value);\nvoid unset_env_value(char ***env_ptr, const char *name);\nvoid expand_variables(char *str, char **env);\n\n#endif"
                    },
                    "parser.h": {
                        type: "file",
                        content: "#ifndef PARSER_H\n#define PARSER_H\n\n#include \"mysh.h\"\n\n#define MAX_ARGS 128\n\n// Command structure\ntypedef struct command_s {\n    char *args[MAX_ARGS];\n    char *input_file;\n    char *output_file;\n    int append_output;\n    struct command_s *pipe_cmd;\n} command_t;\n\n// Parsing functions\nint parse_command(char *input, command_t *cmd);\nint tokenize_command(char *input, command_t *cmd);\nvoid check_redirections(char *input, command_t *cmd);\nvoid setup_redirections(command_t *cmd);\nvoid free_command(command_t *cmd);\n\n#endif"
                    }
                }
            },
            "tests": {
                type: "directory",
                contents: {
                    "test_builtins.c": {
                        type: "file",
                        content: "#include <criterion/criterion.h>\n#include \"../include/mysh.h\"\n\nTest(builtins, test_is_builtin) {\n    cr_assert(is_builtin(\"cd\"));\n    cr_assert(is_builtin(\"exit\"));\n    cr_assert(is_builtin(\"env\"));\n    cr_assert(is_builtin(\"setenv\"));\n    cr_assert(is_builtin(\"unsetenv\"));\n    cr_assert(!is_builtin(\"ls\"));\n    cr_assert(!is_builtin(\"grep\"));\n}"
                    },
                    "test_env.c": {
                        type: "file",
                        content: "#include <criterion/criterion.h>\n#include \"../include/mysh.h\"\n\nTest(env, test_get_env_value) {\n    char *env[] = {\n        \"HOME=/home/user\",\n        \"PATH=/usr/bin:/bin\",\n        \"USER=testuser\",\n        NULL\n    };\n    \n    cr_assert_str_eq(get_env_value(env, \"HOME\"), \"/home/user\");\n    cr_assert_str_eq(get_env_value(env, \"PATH\"), \"/usr/bin:/bin\");\n    cr_assert_str_eq(get_env_value(env, \"USER\"), \"testuser\");\n    cr_assert_null(get_env_value(env, \"NOTEXIST\"));\n}"
                    }
                }
            },
            "Makefile": {
                type: "file",
                content: "NAME = mysh\nSRC = src/main.c src/builtins.c src/execute.c src/env_manager.c src/parser.c src/utils.c\nOBJ = $(SRC:.c=.o)\nINCLUDE = -I./include\nCFLAGS = -Wall -Wextra -Werror $(INCLUDE)\nCRITERION = -lcriterion\n\nall: $(NAME)\n\n$(NAME): $(OBJ)\n\tgcc -o $(NAME) $(OBJ)\n\n%.o: %.c\n\tgcc $(CFLAGS) -c $< -o $@\n\nclean:\n\trm -f $(OBJ)\n\nfclean: clean\n\trm -f $(NAME)\n\nre: fclean all\n\ntest_build:\n\tgcc $(CFLAGS) -c tests/test_builtins.c -o tests/test_builtins.o\n\tgcc $(CFLAGS) -c tests/test_env.c -o tests/test_env.o\n\tgcc $(CFLAGS) -c src/builtins.c -o src/builtins_test.o\n\tgcc $(CFLAGS) -c src/env_manager.c -o src/env_manager_test.o\n\tgcc -o unit_tests tests/test_builtins.o tests/test_env.o src/builtins_test.o src/env_manager_test.o $(CRITERION)\n\ntest: test_build\n\t./unit_tests\n\n.PHONY: all clean fclean re test test_build"
            }
        }
    }
};

// Fonctions utilitaires pour naviguer dans le système de fichiers
function getPath(path) {
    if (path.startsWith("~")) {
        path = path.replace("~", "~/mysh");
    }
    return path;
}

function resolvePath(basePath, targetPath) {
    if (targetPath.startsWith("/") || targetPath.startsWith("~")) {
        return getPath(targetPath);
    }
    
    const base = basePath.split("/");
    const parts = targetPath.split("/");
    
    for (const part of parts) {
        if (part === "..") {
            if (base.length > 1) base.pop();
        } else if (part !== "." && part !== "") {
            base.push(part);
        }
    }
    
    return base.join("/");
}

function getFileOrDir(path) {
    path = getPath(path);
    const parts = path.split("/");
    let current = fileSystem;
    
    for (let i = 0; i < parts.length; i++) {
        if (parts[i] === "" || parts[i] === "~") continue;
        
        if (!current[parts.slice(0, i+1).join("/")]) {
            return null;
        }
        current = current[parts.slice(0, i+1).join("/")];
    }
    
    return current;
}

// Système d'historique amélioré
const historyManager = {
    commands: [],
    maxHistory: 100,
    currentIndex: -1,
    
    add(command) {
        if (command.trim() === "") return;
        
        // Éviter les doublons consécutifs
        if (this.commands.length > 0 && this.commands[this.commands.length - 1] === command) {
            return;
        }
        
        // Limiter la taille de l'historique
        if (this.commands.length >= this.maxHistory) {
            this.commands.shift();
        }
        
        this.commands.push(command);
        this.currentIndex = this.commands.length;
    },
    
    getPrevious() {
        if (this.currentIndex > 0) {
            this.currentIndex--;
            return this.commands[this.currentIndex];
        }
        return null;
    },
    
    getNext() {
        if (this.currentIndex < this.commands.length - 1) {
            this.currentIndex++;
            return this.commands[this.currentIndex];
        }
        this.currentIndex = this.commands.length;
        return "";
    },
    
    searchBackward(prefix) {
        for (let i = this.currentIndex - 1; i >= 0; i--) {
            if (this.commands[i].startsWith(prefix)) {
                this.currentIndex = i;
                return this.commands[i];
            }
        }
        return null;
    },
    
    getAll() {
        return this.commands.map((cmd, idx) => `${idx + 1}  ${cmd}`).join('\n');
    }
};

// Système d'alias
const aliasManager = {
    aliases: {
        "ll": "ls -l",
        "la": "ls -la",
        "c": "clear"
    },
    
    add(name, value) {
        this.aliases[name] = value;
    },
    
    remove(name) {
        delete this.aliases[name];
    },
    
    expand(command) {
        const parts = command.trim().split(/\s+/);
        if (parts.length === 0) return command;
        
        const alias = this.aliases[parts[0]];
        if (!alias) return command;
        
        return `${alias} ${parts.slice(1).join(' ')}`.trim();
    },
    
    getAll() {
        return Object.entries(this.aliases)
            .map(([name, value]) => `alias ${name}='${value}'`)
            .join('\n');
    }
};

// Système de complétion amélioré
const completionManager = {
    getCompletions(input) {
        const lastWord = input.split(/\s+/).pop() || "";
        const isFirstWord = input.trim() === lastWord;
        
        if (isFirstWord) {
            // Compléter avec les commandes et les alias
            const commands = Object.keys(availableCommands);
            const aliases = Object.keys(aliasManager.aliases);
            return [...commands, ...aliases].filter(cmd => cmd.startsWith(lastWord));
        } else {
            // Compléter avec les fichiers et dossiers
            const currentDir = getFileOrDir(currentDirectory);
            if (currentDir && currentDir.type === "directory") {
                return Object.keys(currentDir.contents).filter(name => 
                    name.startsWith(lastWord)
                );
            }
        }
        
        return [];
    },
    
    applyCompletion(input, completion) {
        const parts = input.split(/\s+/);
        parts[parts.length - 1] = completion;
        return parts.join(' ');
    }
};

// Système de piping simple
function executePipe(leftCmd, rightCmd) {
    // Simuler l'exécution d'un pipe
    const leftOutput = executeSingleCommand(leftCmd);
    if (leftOutput === null) return "Commande non trouvée: " + leftCmd.split(/\s+/)[0];
    
    // Utiliser la sortie de la commande gauche comme entrée pour la commande droite
    return executeSingleCommand(rightCmd, leftOutput);
}

function executeSingleCommand(command, input = null) {
    const parts = command.trim().split(/\s+/);
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1).join(" ");
    
    if (availableCommands[cmd]) {
        return availableCommands[cmd](args, input);
    } else {
        return null;
    }
}

// Commandes disponibles pour la simulation - Améliorées
const availableCommands = {
    "ls": (args, input = null) => {
        let path = currentDirectory;
        let showHidden = false;
        let longFormat = false;
        
        if (args) {
            const argsList = args.split(/\s+/);
            argsList.forEach(arg => {
                if (arg.startsWith("-")) {
                    if (arg.includes("a")) showHidden = true;
                    if (arg.includes("l")) longFormat = true;
                } else if (arg) {
                    path = resolvePath(currentDirectory, arg);
                }
            });
        }
        
        const dir = getFileOrDir(path);
        if (!dir || dir.type !== "directory") {
            return `ls: cannot access '${path}': No such file or directory`;
        }
        
        let result = [];
        Object.keys(dir.contents).forEach(key => {
            const item = dir.contents[key];
            if (!key.startsWith(".") || showHidden) {
                if (longFormat) {
                    const permissions = item.type === "directory" ? "drwxr-xr-x" : "-rw-r--r--";
                    const size = item.type === "file" ? 
                        (item.content ? item.content.length : Math.floor(Math.random() * 10000)) : 4096;
                    const date = new Date().toLocaleString("fr-FR", { 
                        month: "short", 
                        day: "numeric", 
                        hour: "2-digit", 
                        minute: "2-digit" 
                    });
                    result.push(`${permissions} 1 ${envVariables["USER"]} ${envVariables["USER"]} ${size.toString().padStart(6)} ${date} ${key}${item.type === "directory" ? "/" : ""}`);
                } else {
                    result.push(`${key}${item.type === "directory" ? "/" : ""}`);
                }
            }
        });
        
        return result.join('\n');
    },
    
    "cd": (args) => {
        const target = args.trim() || "~";
        const newPath = resolvePath(currentDirectory, target);
        const dir = getFileOrDir(newPath);
        
        if (!dir) {
            return `cd: no such file or directory: ${target}`;
        }
        
        if (dir.type !== "directory") {
            return `cd: not a directory: ${target}`;
        }
        
        currentDirectory = newPath;
        envVariables["PWD"] = newPath;
        return "";  // cd ne retourne rien en cas de succès
    },
    
    "pwd": () => {
        return currentDirectory;
    },
    
    "echo": (args) => {
        let text = args;
        
        // Gestion des variables d'environnement
        const varRegex = /\$([A-Za-z_][A-Za-z0-9_]*)/g;
        text = text.replace(varRegex, (match, varName) => {
            return envVariables[varName] || "";
        });
        
        // Gestion des guillemets
        if ((text.startsWith('"') && text.endsWith('"')) || 
            (text.startsWith("'") && text.endsWith("'"))) {
            text = text.slice(1, -1);
        }
        
        return text;
    },
    
    "cat": (args, input = null) => {
        // Si l'entrée est fournie (via pipe), l'afficher
        if (input !== null) {
            return input;
        }
        
        const argsList = args.split(/\s+/);
        if (argsList.length === 0 || !argsList[0]) {
            return "Usage: cat <filename>";
        }
        
        const path = resolvePath(currentDirectory, argsList[0]);
        const file = getFileOrDir(path);
        
        if (!file) {
            return `cat: ${argsList[0]}: No such file or directory`;
        }
        
        if (file.type !== "file") {
            return `cat: ${argsList[0]}: Is a directory`;
        }
        
        return file.content;
    },
    
    "grep": (args, input = null) => {
        const argsList = args.split(/\s+/);
        if (argsList.length < 1) {
            return "Usage: grep <pattern> [file]";
        }
        
        const pattern = argsList[0];
        let content = "";
        
        if (input !== null) {
            // Utiliser l'entrée du pipe
            content = input;
        } else if (argsList.length > 1) {
            // Lire depuis un fichier
            const path = resolvePath(currentDirectory, argsList[1]);
            const file = getFileOrDir(path);
            
            if (!file) {
                return `grep: ${argsList[1]}: No such file or directory`;
            }
            
            if (file.type !== "file") {
                return `grep: ${argsList[1]}: Is a directory`;
            }
            
            content = file.content;
        } else {
            return "Usage: grep <pattern> [file]";
        }
        
        // Filtrer les lignes correspondant au motif
        const lines = content.split('\n');
        const matchingLines = lines.filter(line => line.includes(pattern));
        return matchingLines.join('\n');
    },
    
    "clear": () => {
        terminalContent.innerHTML = "";
        return "";
    },
    
    "exit": () => {
        shellRunning = false;
        promptContainer.style.display = "none";
        terminalContent.innerHTML += "<div>Exiting shell...</div>";
        return "";
    },
    
    "history": (args) => {
        return historyManager.getAll();
    },
    
    "alias": (args) => {
        if (!args.trim()) {
            return aliasManager.getAll();
        }
        
        // Format: alias name='value'
        const match = args.match(/^([a-zA-Z0-9_]+)=(['"])(.*)\2$/);
        if (match) {
            const [, name, , value] = match;
            aliasManager.add(name, value);
            return "";
        }
        
        return "Usage: alias or alias name='value'";
    },
    
    "unalias": (args) => {
        const name = args.trim();
        if (!name) {
            return "Usage: unalias name";
        }
        
        aliasManager.remove(name);
        return "";
    },
    
    "env": () => {
        return Object.entries(envVariables)
            .map(([key, value]) => `${key}=${value}`)
            .join('\n');
    },
    
    "export": (args) => {
        const match = args.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$/);
        if (match) {
            const [, name, value] = match;
            envVariables[name] = value;
            return "";
        }
        
        return "Usage: export NAME=value";
    },
    
    "mkdir": (args) => {
        const dirName = args.trim();
        if (!dirName) {
            return "Usage: mkdir <directory>";
        }
        
        const parentPath = currentDirectory;
        const newPath = resolvePath(parentPath, dirName);
        const parent = getFileOrDir(parentPath);
        
        if (!parent || parent.type !== "directory") {
            return `mkdir: cannot create directory '${dirName}': No such file or directory`;
        }
        
        // Créer le dossier
        fileSystem[newPath] = {
            type: "directory",
            contents: {}
        };
        
        return "";
    },
    
    "touch": (args) => {
        const fileName = args.trim();
        if (!fileName) {
            return "Usage: touch <filename>";
        }
        
        const parentPath = currentDirectory;
        const parent = getFileOrDir(parentPath);
        
        if (!parent || parent.type !== "directory") {
            return `touch: cannot touch '${fileName}': No such file or directory`;
        }
        
        // Créer le fichier s'il n'existe pas
        if (!parent.contents[fileName]) {
            parent.contents[fileName] = {
                type: "file",
                content: ""
            };
        }
        
        return "";
    },
    
    "help": () => {
        return `Available commands:
ls [options] [directory] - List directory contents
cd [directory] - Change directory
pwd - Print working directory
echo [text] - Display text
cat [file] - Display file content
grep <pattern> [file] - Search for pattern
clear - Clear terminal
exit - Exit shell
history - Show command history
alias [name='value'] - Set or display aliases
unalias <name> - Remove alias
env - Display environment variables
export NAME=value - Set environment variable
mkdir <directory> - Create directory
touch <file> - Create empty file
help - Display this help message`;
    }
};

// Fonction pour exécuter les commandes
function executeCommand(command) {
    if (!command.trim()) return "";
    
    // Ajouter à l'historique
    historyManager.add(command);
    
    // Développer les alias
    command = aliasManager.expand(command);
    
    // Gérer les pipes
    if (command.includes("|")) {
        const cmds = command.split("|").map(cmd => cmd.trim());
        let result = executeSingleCommand(cmds[0]);
        
        for (let i = 1; i < cmds.length; i++) {
            if (result === null) {
                return `Commande non trouvée: ${cmds[i-1].split(/\s+/)[0]}`;
            }
            result = executeSingleCommand(cmds[i], result);
        }
        
        return result !== null ? result : `Commande non trouvée: ${cmds[cmds.length-1].split(/\s+/)[0]}`;
    }
    
    // Exécuter une commande simple
    const result = executeSingleCommand(command);
    return result !== null ? result : `Commande non trouvée: ${command.split(/\s+/)[0]}`;
}

// Mise à jour de l'invite de commande
function updatePrompt() {
    const shortDir = currentDirectory.replace(/^~\/mysh/, "~");
    prompt.innerHTML = `${envVariables["USER"]}@shell:${shortDir}$ `;
}

// Lancement du shell
function startShell() {
    shellRunning = true;
    promptContainer.style.display = "flex";
    terminalContent.innerHTML += "<div>Welcome to the Mini Shell Simulator!</div>";
    terminalContent.innerHTML += "<div>Type 'help' to see available commands.</div>";
    
    updatePrompt();
    commandInput.focus();
}

// Arrêt du shell
function stopShell() {
    shellRunning = false;
    promptContainer.style.display = "none";
}

// Gestion des entrées
commandInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
        event.preventDefault();
        
        const command = commandInput.value;
        
        // Ajouter la commande à l'affichage du terminal
        terminalContent.innerHTML += `<div><span class="prompt">${prompt.innerHTML}</span>${command}</div>`;
        
        // Exécuter la commande
        if (shellRunning) {
            const output = executeCommand(command);
            if (output) {
                terminalContent.innerHTML += `<div>${output}</div>`;
            }
        }
        
        // Réinitialiser l'entrée
        commandInput.value = '';
        
        // Mettre à jour l'invite
        updatePrompt();
        
        // Faire défiler vers le bas
        terminalContent.scrollTop = terminalContent.scrollHeight;
    } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        const prev = historyManager.getPrevious();
        if (prev !== null) {
            commandInput.value = prev;
        }
    } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        commandInput.value = historyManager.getNext();
    } else if (event.key === 'Tab') {
        event.preventDefault();
        
        const completions = completionManager.getCompletions(commandInput.value);
        if (completions.length === 1) {
            commandInput.value = completionManager.applyCompletion(commandInput.value, completions[0]);
        } else if (completions.length > 1) {
            // Afficher les complétions possibles
            terminalContent.innerHTML += `<div><span class="prompt">${prompt.innerHTML}</span>${commandInput.value}</div>`;
            terminalContent.innerHTML += `<div>${completions.join('  ')}</div>`;
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }
    }
});

// Bouton de lancement du shell
launchShellBtn.addEventListener('click', () => {
    if (!shellRunning) {
        startShell();
    }
});

// Style CSS pour le terminal
document.head.innerHTML += `
<style>
    #terminal {
        width: 100%;
        height: 400px;
        background-color: #2b2b2b;
        color: #f8f8f2;
        font-family: monospace;
        border-radius: 5px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    #terminalContent {
        flex: 1;
        padding: 10px;
        overflow-y: auto;
        white-space: pre-wrap;
    }
    
    #promptContainer {
        display: none;
        background-color: #2b2b2b;
        padding: 0 10px 10px;
    }
    
    #prompt {
        color: #50fa7b;
    }
    
    #commandInput {
        flex: 1;
        background: none;
        border: none;
        color: #f8f8f2;
        font-family: monospace;
        outline: none;
    }
    
    #launchShellBtn {
        margin-top: 10px;
        padding: 5px 10px;
        background-color: #50fa7b;
        border: none;
        border-radius: 3px;
        cursor: pointer;
    }
    
    .prompt {
        color: #50fa7b;
    }
</style>
`;
    </script>
</body>
</html>
