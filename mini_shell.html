<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Shell | Aurélien Loyer</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <meta name="description" content="Détails du projet Mini Shell d'Aurélien Loyer, un shell simplifié en langage C.">
    <style>
        .terminal-container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-header {
            background-color: #333;
            padding: 8px 12px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: -10px -10px 10px -10px;
        }
        
        .terminal-title {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .terminal-buttons {
            display: flex;
        }
        
        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .button-red {
            background-color: #ff5f56;
        }
        
        .button-yellow {
            background-color: #ffbd2e;
        }
        
        .button-green {
            background-color: #27c93f;
        }
        
        .terminal-content {
            color: #f8f8f2;
            white-space: pre-wrap;
            line-height: 1.5;
            min-height: 280px;
        }
        
        .terminal-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .terminal-prompt {
            color: #50fa7b;
            margin-right: 8px;
        }
        
        .terminal-command {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
        }

        .light-theme .terminal-container {
            background-color: #2a2a2a;
        }
        
        .light-theme .terminal-header {
            background-color: #444;
        }
        
        .light-theme .terminal-content,
        .light-theme .terminal-command {
            color: #e6e6e6;
        }
        
        .try-it-button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #50fa7b;
            color: #1e1e1e;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .try-it-button:hover {
            background-color: #2ebd5a;
        }
        
        .light-theme .try-it-button {
            background-color: #2ebd5a;
            color: #fff;
        }
        
        .light-theme .try-it-button:hover {
            background-color: #1a9043;
        }

        /* Ajout pour le terminal interactif */
        .interactive-prompt {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        #commandInput {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
            caret-color: #f8f8f2;
        }

        .light-theme #commandInput {
            color: #e6e6e6;
            caret-color: #e6e6e6;
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrapper">
        <div class="loader">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <!-- Navbar -->
    <nav class="navbar" id="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">AL<span class="dot">.</span></a>
            </div>
            <div class="nav-menu">
                <ul class="nav-links">
                    <li><a href="index.html#home" class="nav-link">Accueil</a></li>
                    <li><a href="index.html#about" class="nav-link">À propos</a></li>
                    <li><a href="index.html#skills" class="nav-link">Compétences</a></li>
                    <li><a href="index.html#projects" class="nav-link active">Projets</a></li>
                    <li><a href="index.html#contact" class="nav-link">Contact</a></li>
                </ul>
                <div class="nav-actions">
                    <button class="theme-toggle" id="theme-toggle" aria-label="Changer de thème">
                        <i class="fas fa-moon"></i>
                    </button>
                    <a href="cv_loyeraurelien.pdf" class="btn btn-outline" target="_blank">
                        <i class="fas fa-file-alt"></i> Mon CV
                    </a>
                </div>
            </div>
            <div class="hamburger" id="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- Project Header -->
    <section class="project-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="index.html">Accueil</a> / 
                <a href="index.html#projects">Projets</a> / 
                <span>Mini Shell</span>
            </div>
            <h1 class="project-title">Mini Shell</h1>
            <div class="project-meta">
                <div class="meta-item">
                    <i class="fas fa-calendar-alt"></i>
                    <span>2024</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-code"></i>
                    <span>C</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-terminal"></i>
                    <span>Shell</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Project Content -->
    <section class="project-content">
        <div class="container">
            <div class="project-details">
                <div class="project-demo">
                    <h2>Démonstration</h2>
                    <div class="video-container">
                        <video controls>
                            <source src="videos/mini_shell_demo.mp4" type="video/mp4">
                            Votre navigateur ne supporte pas la lecture de vidéos.
                        </video>
                    </div>
                </div>

                <div class="project-overview">
                    <h2>Aperçu du projet</h2>
                    <p>
                        Mini Shell est un interpréteur de commandes simplifié développé en langage C. Ce projet avait pour objectif de créer un terminal capable d'exécuter des commandes de base du système Unix et de gérer différentes fonctionnalités intégrées (builtins).
                    </p>
                </div>

                <div class="project-features">
                    <h2>Fonctionnalités</h2>
                    <ul>
                        <li><i class="fas fa-check-circle"></i> Exécution de commandes externes (ls, cat, grep, etc.)</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des commandes intégrées (cd, exit, env, setenv, unsetenv)</li>
                        <li><i class="fas fa-check-circle"></i> Support des variables d'environnement</li>
                        <li><i class="fas fa-check-circle"></i> Gestion du changement de répertoire</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des erreurs et des exceptions</li>
                    </ul>
                </div>

                <div class="project-technical">
                    <h2>Aspects techniques</h2>
                    <p>
                        Ce shell a été implémenté en C, en utilisant diverses fonctions système comme fork(), execve(), waitpid() pour la gestion des processus enfants. L'environnement système est géré à travers une structure de données personnalisée permettant la manipulation des variables d'environnement.
                    </p>
                    
                    <h3>Essayez Mini Shell (en très très simplifié ...) en direct!</h3>
                    
                    <div class="terminal-container" id="terminalContainer">
                        <div class="terminal-header">
                            <div class="terminal-buttons">
                                <div class="terminal-button button-red"></div>
                                <div class="terminal-button button-yellow"></div>
                                <div class="terminal-button button-green"></div>
                            </div>
                            <div class="terminal-title">Terminal - Mini Shell</div>
                            <div style="width: 50px;"></div>
                        </div>
                        <div class="terminal-content" id="terminalContent">Prêt à exécuter Mini Shell...</div>
                        <div class="interactive-prompt" id="promptContainer" style="display: none;">
                            <span class="terminal-prompt" id="prompt">$</span>
                            <input type="text" id="commandInput" autocomplete="off" spellcheck="false">
                        </div>
                    </div>
                    
                    <button class="try-it-button" id="launchShellBtn">
                        <i class="fas fa-terminal"></i> Lancer mysh
                    </button>
                </div>

                <div class="project-challenges">
                    <h2>
                    Défis et solutions</h2>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Gestion des processus</h3>
                        <p>
                            Un des principaux défis était la gestion correcte des processus enfants pour éviter les fuites de mémoire et les processus zombies. J'ai résolu ce problème en implémentant un système robuste de suivi des processus avec waitpid().
                        </p>
                    </div>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Manipulation de l'environnement</h3>
                        <p>
                            La gestion des variables d'environnement nécessitait une attention particulière, notamment pour les commandes setenv et unsetenv. J'ai développé une structure de données dédiée pour faciliter ces opérations.
                        </p>
                    </div>
                </div>

                <div class="project-learnings">
                    <h2>Ce que j'ai appris</h2>
                    <p>
                        Ce projet m'a permis d'approfondir mes connaissances sur:
                    </p>
                    <ul>
                        <li>Le fonctionnement interne des shells Unix</li>
                        <li>La gestion des processus en C</li>
                        <li>Les appels système Linux/Unix</li>
                        <li>La manipulation avancée de chaînes de caractères</li>
                        <li>La gestion efficace de la mémoire</li>
                    </ul>
                </div>

                <div class="project-links">
                    <h2>Liens</h2>
                    <a href="https://github.com/aurelien-loyer/mini_shell" class="btn btn-primary" target="_blank">
                        <i class="fab fa-github"></i> Code source
                    </a>
                </div>
            </div>

            <div class="other-projects">
                <h2>Autres projets</h2>
                <div class="projects-grid small-grid">
                    <div class="project-card" data-category="csfml">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">My Radar</h3>
                            <p class="project-description">Simulateur de contrôle aérien avec CSFML</p>
                            <a href="my_radar.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="c">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">Organized</h3>
                            <p class="project-description">Programme d'organisation de données</p>
                            <a href="organized.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="python">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">105demography</h3>
                            <p class="project-description">Analyse démographique en Python</p>
                            <a href="105demography.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <a href="index.html">AL<span class="dot">.</span></a>
                    <p>Développeur passionné</p>
                </div>
                
                <div class="footer-links">
                    <h3>Liens rapides</h3>
                    <ul>
                        <li><a href="index.html#home">Accueil</a></li>
                        <li><a href="index.html#about">À propos</a></li>
                        <li><a href="index.html#skills">Compétences</a></li>
                        <li><a href="index.html#projects">Projets</a></li>
                        <li><a href="index.html#contact">Contact</a></li>
                    </ul>
                </div>
                
                <div class="footer-social">
                    <h3>Me suivre</h3>
                    <div class="social-icons">
                        <a href="https://github.com/aurelien-loyer" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/aurelien-loyer-epi/" target="_blank">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="mailto:aurelien.loyer@epitech.eu">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>© 2025 Aurélien Loyer. Tous droits réservés.</p>
                <a href="#" class="back-to-top">
                    <i class="fas fa-arrow-up"></i>
                </a>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Loader
            setTimeout(() => {
                document.querySelector('.loader-wrapper').style.opacity = '0';
                setTimeout(() => {
                    document.querySelector('.loader-wrapper').style.display = 'none';
                }, 500);
            }, 1000);

            // Mobile Menu Toggle
            const hamburger = document.getElementById('hamburger');
            const navMenu = document.querySelector('.nav-menu');
            
            hamburger.addEventListener('click', function() {
                this.classList.toggle('active');
                navMenu.classList.toggle('active');
            });

            // Sticky Header
            window.addEventListener('scroll', function() {
                const navbar = document.getElementById('navbar');
                if (window.scrollY > 50) {
                    navbar.classList.add('sticky');
                } else {
                    navbar.classList.remove('sticky');
                }
            });

            // Dark/Light Theme Toggle
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('i');
            const currentTheme = localStorage.getItem('theme') || 'dark';
            
            // Set initial theme
            if (currentTheme === 'light') {
                document.body.classList.add('light-theme');
                themeIcon.classList.replace('fa-moon', 'fa-sun');
            }
            
            themeToggle.addEventListener('click', () => {
                document.body.classList.toggle('light-theme');
                
                if (document.body.classList.contains('light-theme')) {
                    localStorage.setItem('theme', 'light');
                    themeIcon.classList.replace('fa-moon', 'fa-sun');
                } else {
                    localStorage.setItem('theme', 'dark');
                    themeIcon.classList.replace('fa-sun', 'fa-moon');
                }
            });

            // Smooth scrolling
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    const targetId = this.getAttribute('href');
                    if (targetId === '#') return;
                    
                    const targetElement = document.querySelector(targetId);
                    
                    window.scrollTo({
                        top: targetElement.offsetTop - 70,
                        behavior: 'smooth'
                    });
                });
            });
            
            // Variables pour le terminal interactif
            const terminalContent = document.getElementById('terminalContent');
            const launchShellBtn = document.getElementById('launchShellBtn');
            const promptContainer = document.getElementById('promptContainer');
            const commandInput = document.getElementById('commandInput');
            const prompt = document.getElementById('prompt');

            // État du shell
            let shellRunning = false;
            let currentDirectory = "~/mysh";
            let envVariables = {
                "HOME": "~/mysh",
                "PATH": "/usr/local/bin:/usr/bin:/bin",
                "USER": "user",
                "PWD": "~/mysh",
                "SHELL": "~/mysh/mysh"
            };

            // Structure de fichiers simulée
            const fileSystem = {
                "~/mysh": {
                    type: "directory",
                    contents: {
                        "README.md": {
                            type: "file",
                            content: "# Mini Shell\n\nShell simplifié en langage C\n\n## Compilation\n\n```\nmake\n```\n\n## Utilisation\n\n```\n./mysh\n```"
                        },
                        "src": {
                            type: "directory",
                            contents: {
                                "main.c": {
                                    type: "file",
                                    content: "#include \"../include/mysh.h\"\n\nint main(int argc, char **argv, char **env) {\n    // Initialize environment\n    char **env_copy = copy_environment(env);\n    \n    // Start command loop\n    run_shell(env_copy);\n    \n    // Clean up before exit\n    free_environment(env_copy);\n    return 0;\n}"
                                },
                                "builtins.c": {
                                    type: "file",
                                    content: "#include \"../include/builtins.h\"\n\nvoid builtin_cd(char **args, char **env) {\n    // Implementation of cd command\n    if (args[1] == NULL) {\n        chdir(getenv(\"HOME\"));\n    } else {\n        if (chdir(args[1]) != 0) {\n            fprintf(stderr, \"cd: %s: No such file or directory\\n\", args[1]);\n        }\n    }\n}"
                                },
                                "execute.c": {
                                    type: "file",
                                    content: "#include \"../include/mysh.h\"\n\nvoid execute_command(char *command, char **env) {\n    // Parse command\n    char **args = parse_command(command);\n    \n    // Check if builtin\n    if (is_builtin(args[0])) {\n        execute_builtin(args, env);\n        free_args(args);\n        return;\n    }\n    \n    // Fork and execute\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        execve(args[0], args, env);\n        fprintf(stderr, \"%s: Command not found\\n\", args[0]);\n        exit(1);\n    } else if (pid > 0) {\n        // Parent process\n        int status;\n        waitpid(pid, &status, 0);\n    }\n    \n    free_args(args);\n}"
                                },
                                "env_manager.c": {
                                    type: "file",
                                    content: "#include \"../include/env_manager.h\"\n\nchar **copy_environment(char **env) {\n    int count = 0;\n    while (env[count] != NULL)\n        count++;\n    \n    char **env_copy = malloc(sizeof(char *) * (count + 1));\n    for (int i = 0; i < count; i++)\n        env_copy[i] = strdup(env[i]);\n    env_copy[count] = NULL;\n    \n    return env_copy;\n}"
                                },
                                "utils.c": {
                                    type: "file",
                                    content: "#include \"../include/mysh.h\"\n\nchar **parse_command(char *command) {\n    // Tokenize command by spaces\n    int max_tokens = 64;\n    char **tokens = malloc(sizeof(char *) * max_tokens);\n    char *token = strtok(command, \" \\t\\n\");\n    int pos = 0;\n    \n    while (token != NULL && pos < max_tokens - 1) {\n        tokens[pos++] = strdup(token);\n        token = strtok(NULL, \" \\t\\n\");\n    }\n    tokens[pos] = NULL;\n    return tokens;\n}"
                                }
                            }
                        },
                        "include": {
                            type: "directory",
                            contents: {
                                "mysh.h": {
                                    type: "file",
                                    content: "#ifndef MYSH_H\n#define MYSH_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n// Shell functions\nvoid run_shell(char **env);\nvoid execute_command(char *command, char **env);\nchar **parse_command(char *command);\n\n// Builtin functions\nint is_builtin(char *command);\nvoid execute_builtin(char **args, char **env);\n\n// Environment management\nchar **copy_environment(char **env);\nvoid free_environment(char **env);\n\n// Memory management\nvoid free_args(char **args);\n\n#endif"
                                },
                                "builtins.h": {
                                    type: "file",
                                    content: "#ifndef BUILTINS_H\n#define BUILTINS_H\n\n#include \"mysh.h\"\n\n// Builtin commands\nvoid builtin_cd(char **args, char **env);\nvoid builtin_exit(char **args, char **env);\nvoid builtin_env(char **args, char **env);\nvoid builtin_setenv(char **args, char **env);\nvoid builtin_unsetenv(char **args, char **env);\n\n#endif"
                                },
                                "env_manager.h": {
                                    type: "file",
                                    content: "#ifndef ENV_MANAGER_H\n#define ENV_MANAGER_H\n\n#include \"mysh.h\"\n\n// Environment variable functions\nchar **copy_environment(char **env);\nvoid free_environment(char **env);\nchar *get_env_value(char **env, const char *name);\nvoid set_env_value(char ***env, const char *name, const char *value);\nvoid unset_env_value(char ***env, const char *name);\n\n#endif"
                                }
                            }
                        },
                        "Makefile": {
                            type: "file",
                            content: "NAME = mysh\nSRC = src/main.c src/builtins.c src/execute.c src/env_manager.c src/utils.c\nOBJ = $(SRC:.c=.o)\nCFLAGS = -Wall -Wextra -I./include\n\nall: $(NAME)\n\n$(NAME): $(OBJ)\n\tgcc -o $(NAME) $(OBJ)\n\nclean:\n\trm -f $(OBJ)\n\nfclean: clean\n\trm -f $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re"
                        }
                    }
                }
            };

            // Fonctions utilitaires pour naviguer dans le système de fichiers
            function getPath(path) {
                if (path.startsWith("~")) {
                    path = path.replace("~", "~/mysh");
                }
                return path;
            }

            function resolvePath(basePath, targetPath) {
                if (targetPath.startsWith("/") || targetPath.startsWith("~")) {
                    return getPath(targetPath);
                }
                
                const base = basePath.split("/");
                const parts = targetPath.split("/");
                
                for (const part of parts) {
                    if (part === "..") {
                        if (base.length > 1) base.pop();
                    } else if (part !== "." && part !== "") {
                        base.push(part);
                    }
                }
                
                return base.join("/");
            }

            function getFileOrDir(path) {
                path = getPath(path);
                const parts = path.split("/");
                let current = fileSystem;
                
                for (let i = 0; i < parts.length; i++) {
                    if (parts[i] === "" || parts[i] === "~") continue;
                    
                    if (!current[parts.slice(0, i+1).join("/")]) {
                        return null;
                    }
                    current = current[parts.slice(0, i+1).join("/")];
                }
                
                return current;
            }

            // Commandes disponibles pour la simulation
            const availableCommands = {
                "ls": (args) => {
                    let path = currentDirectory;
                    let showHidden = false;
                    let longFormat = false;
                    
                    if (args) {
                        const argsList = args.split(/\s+/);
                        argsList.forEach(arg => {
                            if (arg.startsWith("-")) {
                                if (arg.includes("a")) showHidden = true;
                                if (arg.includes("l")) longFormat = true;
                            } else if (arg) {
                                path = resolvePath(currentDirectory, arg);
                            }
                        });
                    }
                    
                    const dir = getFileOrDir(path);
                    if (!dir || dir.type !== "directory") {
                        return `ls: cannot access '${path}': No such file or directory`;
                    }
                    
                    let result = [];
                    Object.keys(dir.contents).forEach(key => {
                        const item = dir.contents[key];
                        if (!key.startsWith(".") || showHidden) {
                            if (longFormat) {
                                const permissions = item.type === "directory" ? "drwxr-xr-x" : "-rw-r--r--";
                                const size = item.type === "file" ? Math.floor(Math.random() * 10000) : 4096;
                                const date = new Date().toLocaleString("fr-FR", { 
                                    month: "short", 
                                    day: "numeric", 
                                    hour: "2-digit", 
                                    minute: "2-digit" 
                                });
                                result.push(`${permissions} 1 user user ${size.toString().padStart(5)} ${date} ${key}${item.type === "directory" ? "/" : ""}`);
                            } else {
                                result.push(`${key}${item.type === "directory" ? "/" : ""}`);
                            }
                        }
                    });
                    
                    return result.join("\n");
                },
                "pwd": () => currentDirectory,
                "cd": (args) => {
                    let targetPath;
                    
                    if (!args || args === "~") {
                        targetPath = "~/mysh";
                    } else {
                        targetPath = resolvePath(currentDirectory, args);
                    }
                    
                    const dir = getFileOrDir(targetPath);
                    if (!dir) {
                        return `cd: ${args}: No such file or directory`;
                    }
                    
                    if (dir.type !== "directory") {
                        return `cd: ${args}: Not a directory`;
                    }
                    
                    currentDirectory = targetPath;
                    envVariables["PWD"] = currentDirectory;
                    prompt.textContent = `${currentDirectory} $`;
                    return "";
                },
                "cat": (args) => {
                    if (!args) {
                        return "cat: missing operand";
                    }
                    
                    const argsList = args.split(/\s+/);
                    let result = [];
                    
                    for (const arg of argsList) {
                        const path = resolvePath(currentDirectory, arg);
                        const file = getFileOrDir(path);
                        
                        if (!file) {
                            result.push(`cat: ${arg}: No such file or directory`);
                            continue;
                        }
                        
                        if (file.type !== "file") {
                            result.push(`cat: ${arg}: Is a directory`);
                            continue;
                        }
                        
                        result.push(file.content);
                    }
                    
                    return result.join("\n");
                },
                "echo": (args) => {
                    if (!args) return "";
                    
                    // Gestion des variables d'environnement
                    let result = args;
                    const envVarMatches = args.match(/\$([A-Za-z_][A-Za-z0-9_]*)/g);
                    
                    if (envVarMatches) {
                        envVarMatches.forEach(match => {
                            const varName = match.substring(1);
                            if (envVariables[varName]) {
                                result = result.replace(match, envVariables[varName]);
                            } else {
                                result = result.replace(match, "");
                            }
                        });
                    }
                    
                    return result;
                },
                "env": () => {
                    let result = [];
                    Object.keys(envVariables).forEach(key => {
                        result.push(`${key}=${envVariables[key]}`);
                    });
                    return result.join("\n");
                },
                "setenv": (args) => {
                    if (!args) {
                        return availableCommands["env"]();
                    }
                    
                    const parts = args.split(/\s+/);
                    if (parts.length < 2) {
                        return "setenv: Too few arguments.";
                    }
                    
                    envVariables[parts[0]] = parts[1];
                    return "";
                },
                "unsetenv": (args) => {
                    if (!args) {
                        return "unsetenv: Too few arguments.";
                    }
                    
                    const varName = args.split(/\s+/)[0];
                    if (envVariables[varName]) {
                        delete envVariables[varName];
                    }
                    return "";
                },
                "make": (args) => {
                    if (currentDirectory !== "~/mysh" && !currentDirectory.startsWith("~/mysh/")) {
                        return "make: *** No Makefile found. Stop.";
                    }
                    
                    if (!args || args === "all") {
                        return "gcc -Wall -Wextra -I./include -c src/main.c -o src/main.o\ngcc -Wall -Wextra -I./include -c src/builtins.c -o src/builtins.o\ngcc -Wall -Wextra -I./include -c src/execute.c -o src/execute.o\ngcc -Wall -Wextra -I./include -c src/env_manager.c -o src/env_manager.o\ngcc -Wall -Wextra -I./include -c src/utils.c -o src/utils.o\ngcc -o mysh src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o";
                    } else if (args === "clean") {
                        return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o";
                    } else if (args === "fclean") {
                        return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o\nrm -f mysh";
                    } else if (args === "re") {
                        return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o\nrm -f mysh\ngcc -Wall -Wextra -I./include -c src/main.c -o src/main.o\ngcc -Wall -Wextra -I./include -c src/builtins.c -o src/builtins.o\ngcc -Wall -Wextra -I./include -c src/execute.c -o src/execute.o\ngcc -Wall -Wextra -I./include -c src/env_manager.c -o src/env_manager.o\ngcc -Wall -Wextra -I./include -c src/utils.c -o src/utils.o\ngcc -o mysh src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o";
                    }
                    return `make: *** No rule to make target '${args}'. Stop.`;
                },
                "help": () => {
                    return "Commandes disponibles dans cette simulation:\n- ls [-la] [dossier]: Afficher le contenu du répertoire\n- pwd: Afficher le répertoire courant\n- cd [dossier]: Changer de répertoire\n- cat [fichier]: Afficher le contenu d'un fichier\n- echo [texte]: Afficher du texte\n- env: Afficher les variables d'environnement\n- setenv [var] [valeur]: Définir une variable d'environnement\n- unsetenv [var]: Supprimer une variable d'environnement\n- make [target]: Exécuter des cibles du Makefile\n- clear: Effacer l'écran\n- history: Afficher l'historique des commandes\n- exit: Quitter le Mini Shell\n- help: Afficher cette aide";
                },
                "clear": () => {
                    terminalContent.textContent = "";
                    return "";
                },
                "history": (() => {
                    let commandHistory = [];
                    
                    return () => {
                        if (commandHistory.length === 0) {
                            return "No commands in history";
                        }
                        
                        let result = [];
                        commandHistory.forEach((cmd, index) => {
                            result.push(`${index + 1}  ${cmd}`);
                        });
                        
                        return result.join("\n");
                    };
                })(),
                "exit": () => {
                    shellRunning = false;
                    promptContainer.style.display = "none";
                    terminalContent.textContent += "\nAu revoir!\n";
                    launchShellBtn.innerHTML = '<i class="fas fa-terminal"></i> Lancer mysh';
                    launchShellBtn.classList.remove('active');
                    return null;  // valeur spéciale pour indiquer la sortie
                }
            };

            // Historique des commandes
            let commandHistory = [];
            let historyIndex = -1;

            // Fonction pour traiter les commandes
            function processCommand(commandStr) {
                // Ajouter à l'historique si non vide
                if (commandStr.trim() !== "") {
                    commandHistory.push(commandStr);
                    historyIndex = commandHistory.length;
                }
                
                const parts = commandStr.trim().split(/\s+/);
                const command = parts[0].toLowerCase();
                const args = parts.slice(1).join(" ");
                
                if (command === "") {
                    return "";
                }
                
                if (availableCommands[command]) {
                    const result = availableCommands[command](args);
                    if (result === null) {
                        return null;  // commande exit
                    }
                    return result;
                } else {
                    return `${command}: command not found`;
                }
            }

            // Gestion de l'historique avec les flèches
            commandInput.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        commandInput.value = commandHistory[historyIndex];
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        commandInput.value = commandHistory[historyIndex];
                    } else if (historyIndex === commandHistory.length - 1) {
                        historyIndex = commandHistory.length;
                        commandInput.value = "";
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    // Auto-complétion simple
                    const input = commandInput.value;
                    const lastWord = input.split(/\s+/).pop();
                    
                    if (lastWord) {
                        // Rechercher des correspondances dans les commandes ou fichiers
                        const currentDir = getFileOrDir(currentDirectory);
                        if (currentDir && currentDir.type === "directory") {
                            const matches = Object.keys(currentDir.contents).filter(name => 
                                name.startsWith(lastWord)
                            );
                            
                            if (matches.length === 1) {
                                // Une seule correspondance, compléter
                                const completion = matches[0];
                                const beforeLastWord = input.substring(0, input.length - lastWord.length);
                                commandInput.value = beforeLastWord + completion;
                            }
                        }
                    }
                }
            });

            // Gestion des entrées de commandes
            commandInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const command = commandInput.value;
                    terminalContent.textContent += `${prompt.textContent} ${command}\n`;
                    
                    const result = processCommand(command);
                    if (result !== null) {
                        if (result) {
                            terminalContent.textContent += `${result}\n`;
                        }
                        commandInput.value = "";
                        
                        // Faire défiler vers le bas
                        const container = document.getElementById('terminalContainer');
                        container.scrollTop = container.scrollHeight;
                        
                        // Remettre le focus sur l'input
                        commandInput.focus();
                    }
                }
            });

            // Fonction pour lancer l'exécutable mysh
            function launchMysh() {
                if (shellRunning) {
                    // Si déjà en cours d'exécution, arrêter
                    shellRunning = false;
                    promptContainer.style.display = "none";
                    terminalContent.textContent += "\nArrêt de mysh...\n";
                    terminalContent.textContent += "Mini Shell a été fermé.\n";
                    
                    // Réinitialiser le bouton
                    launchShellBtn.innerHTML = '<i class="fas fa-terminal"></i> Lancer mysh';
                    launchShellBtn.classList.remove('active');
                    return;
                }
                
                // Sinon, démarrer
                terminalContent.textContent = "$ ./mysh\n";
                terminalContent.textContent += "Démarrage de Mini Shell...\n";
                terminalContent.textContent += "Mini Shell v1.0 - Aurélien Loyer\n\n";
                terminalContent.textContent += "Tapez 'help' pour voir les commandes disponibles\n";
                
                // Réinitialiser le répertoire courant
                currentDirectory = "~";
                prompt.textContent = `${currentDirectory} $`;
                
                // Vider l'historique des commandes
                commandHistory = [];
                historyIndex = -1;
                
                // Afficher le prompt d'entrée
                promptContainer.style.display = "flex";
                commandInput.value = "";
                commandInput.focus();
                
                // Changer le texte du bouton pour indiquer qu'on peut arrêter
                launchShellBtn.innerHTML = '<i class="fas fa-stop"></i> Arrêter mysh';
                launchShellBtn.classList.add('active');
                shellRunning = true;
            }

            // Associer l'événement au bouton
            launchShellBtn.addEventListener('click', launchMysh);

            // Assurer que le focus reste sur l'input quand on clique dans le terminal
            document.getElementById('terminalContainer').addEventListener('click', function() {
                if (shellRunning) {
                    commandInput.focus();
                }
            });
        });
    </script>
</body>
</html>
