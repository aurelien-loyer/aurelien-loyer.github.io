<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Shell | Aurélien Loyer</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <meta name="description" content="Détails du projet Mini Shell d'Aurélien Loyer, un shell simplifié en langage C.">
    <style>
        .terminal-container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-header {
            background-color: #333;
            padding: 8px 12px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: -10px -10px 10px -10px;
        }
        
        .terminal-title {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .terminal-buttons {
            display: flex;
        }
        
        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .button-red {
            background-color: #ff5f56;
        }
        
        .button-yellow {
            background-color: #ffbd2e;
        }
        
        .button-green {
            background-color: #27c93f;
        }
        
        .terminal-content {
            color: #f8f8f2;
            white-space: pre-wrap;
            line-height: 1.5;
            min-height: 280px;
        }
        
        .terminal-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .terminal-prompt {
            color: #50fa7b;
            margin-right: 8px;
        }
        
        .terminal-command {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
        }

        .light-theme .terminal-container {
            background-color: #2a2a2a;
        }
        
        .light-theme .terminal-header {
            background-color: #444;
        }
        
        .light-theme .terminal-content,
        .light-theme .terminal-command {
            color: #e6e6e6;
        }
        
        .try-it-button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #50fa7b;
            color: #1e1e1e;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .try-it-button:hover {
            background-color: #2ebd5a;
        }
        
        .light-theme .try-it-button {
            background-color: #2ebd5a;
            color: #fff;
        }
        
        .light-theme .try-it-button:hover {
            background-color: #1a9043;
        }

        /* Ajout pour le terminal interactif */
        .interactive-prompt {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        #commandInput {
            background: transparent;
            border: none;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex-grow: 1;
            outline: none;
            caret-color: #f8f8f2;
        }

        .light-theme #commandInput {
            color: #e6e6e6;
            caret-color: #e6e6e6;
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrapper">
        <div class="loader">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <!-- Navbar -->
    <nav class="navbar" id="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">AL<span class="dot">.</span></a>
            </div>
            <div class="nav-menu">
                <ul class="nav-links">
                    <li><a href="index.html#home" class="nav-link">Accueil</a></li>
                    <li><a href="index.html#about" class="nav-link">À propos</a></li>
                    <li><a href="index.html#skills" class="nav-link">Compétences</a></li>
                    <li><a href="index.html#projects" class="nav-link active">Projets</a></li>
                    <li><a href="index.html#contact" class="nav-link">Contact</a></li>
                </ul>
                <div class="nav-actions">
                    <button class="theme-toggle" id="theme-toggle" aria-label="Changer de thème">
                        <i class="fas fa-moon"></i>
                    </button>
                    <a href="cv_loyeraurelien.pdf" class="btn btn-outline" target="_blank">
                        <i class="fas fa-file-alt"></i> Mon CV
                    </a>
                </div>
            </div>
            <div class="hamburger" id="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- Project Header -->
    <section class="project-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="index.html">Accueil</a> / 
                <a href="index.html#projects">Projets</a> / 
                <span>Mini Shell</span>
            </div>
            <h1 class="project-title">Mini Shell</h1>
            <div class="project-meta">
                <div class="meta-item">
                    <i class="fas fa-calendar-alt"></i>
                    <span>2024</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-code"></i>
                    <span>C</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-terminal"></i>
                    <span>Shell</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Project Content -->
    <section class="project-content">
        <div class="container">
            <div class="project-details">
                <div class="project-demo">
                    <h2>Démonstration</h2>
                    <div class="video-container">
                        <video controls>
                            <source src="videos/mini_shell_demo.mp4" type="video/mp4">
                            Votre navigateur ne supporte pas la lecture de vidéos.
                        </video>
                    </div>
                </div>

                <div class="project-overview">
                    <h2>Aperçu du projet</h2>
                    <p>
                        Mini Shell est un interpréteur de commandes simplifié développé en langage C. Ce projet avait pour objectif de créer un terminal capable d'exécuter des commandes de base du système Unix et de gérer différentes fonctionnalités intégrées (builtins).
                    </p>
                </div>

                <div class="project-features">
                    <h2>Fonctionnalités</h2>
                    <ul>
                        <li><i class="fas fa-check-circle"></i> Exécution de commandes externes (ls, cat, grep, etc.)</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des commandes intégrées (cd, exit, env, setenv, unsetenv)</li>
                        <li><i class="fas fa-check-circle"></i> Support des variables d'environnement</li>
                        <li><i class="fas fa-check-circle"></i> Gestion du changement de répertoire</li>
                        <li><i class="fas fa-check-circle"></i> Gestion des erreurs et des exceptions</li>
                    </ul>
                </div>

                <div class="project-technical">
                    <h2>Aspects techniques</h2>
                    <p>
                        Ce shell a été implémenté en C, en utilisant diverses fonctions système comme fork(), execve(), waitpid() pour la gestion des processus enfants. L'environnement système est géré à travers une structure de données personnalisée permettant la manipulation des variables d'environnement.
                    </p>
                    
                    <h3>Essayez Mini Shell (en très très simplifié ...) en direct!</h3>
                    
                    <div class="terminal-container" id="terminalContainer">
                        <div class="terminal-header">
                            <div class="terminal-buttons">
                                <div class="terminal-button button-red"></div>
                                <div class="terminal-button button-yellow"></div>
                                <div class="terminal-button button-green"></div>
                            </div>
                            <div class="terminal-title">Terminal - Mini Shell</div>
                            <div style="width: 50px;"></div>
                        </div>
                        <div class="terminal-content" id="terminalContent">Prêt à exécuter Mini Shell...</div>
                        <div class="interactive-prompt" id="promptContainer" style="display: none;">
                            <span class="terminal-prompt" id="prompt">$</span>
                            <input type="text" id="commandInput" autocomplete="off" spellcheck="false">
                        </div>
                    </div>
                    
                    <button class="try-it-button" id="launchShellBtn">
                        <i class="fas fa-terminal"></i> Lancer mysh
                    </button>
                </div>

                <div class="project-challenges">
                    <h2>
                    Défis et solutions</h2>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Gestion des processus</h3>
                        <p>
                            Un des principaux défis était la gestion correcte des processus enfants pour éviter les fuites de mémoire et les processus zombies. J'ai résolu ce problème en implémentant un système robuste de suivi des processus avec waitpid().
                        </p>
                    </div>
                    <div class="challenge-item">
                        <h3><i class="fas fa-exclamation-triangle"></i> Manipulation de l'environnement</h3>
                        <p>
                            La gestion des variables d'environnement nécessitait une attention particulière, notamment pour les commandes setenv et unsetenv. J'ai développé une structure de données dédiée pour faciliter ces opérations.
                        </p>
                    </div>
                </div>

                <div class="project-learnings">
                    <h2>Ce que j'ai appris</h2>
                    <p>
                        Ce projet m'a permis d'approfondir mes connaissances sur:
                    </p>
                    <ul>
                        <li>Le fonctionnement interne des shells Unix</li>
                        <li>La gestion des processus en C</li>
                        <li>Les appels système Linux/Unix</li>
                        <li>La manipulation avancée de chaînes de caractères</li>
                        <li>La gestion efficace de la mémoire</li>
                    </ul>
                </div>

                <div class="project-links">
                    <h2>Liens</h2>
                    <a href="https://github.com/aurelien-loyer/mini_shell" class="btn btn-primary" target="_blank">
                        <i class="fab fa-github"></i> Code source
                    </a>
                </div>
            </div>

            <div class="other-projects">
                <h2>Autres projets</h2>
                <div class="projects-grid small-grid">
                    <div class="project-card" data-category="csfml">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">My Radar</h3>
                            <p class="project-description">Simulateur de contrôle aérien avec CSFML</p>
                            <a href="my_radar.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="c">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">Organized</h3>
                            <p class="project-description">Programme d'organisation de données</p>
                            <a href="organized.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>

                    <div class="project-card" data-category="python">
                        <div class="project-image-placeholder"></div>
                        <div class="project-info">
                            <h3 class="project-title">105demography</h3>
                            <p class="project-description">Analyse démographique en Python</p>
                            <a href="105demography.html" class="project-link">Voir les détails <i class="fas fa-arrow-right"></i></a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <a href="index.html">AL<span class="dot">.</span></a>
                    <p>Développeur passionné</p>
                </div>
                
                <div class="footer-links">
                    <h3>Liens rapides</h3>
                    <ul>
                        <li><a href="index.html#home">Accueil</a></li>
                        <li><a href="index.html#about">À propos</a></li>
                        <li><a href="index.html#skills">Compétences</a></li>
                        <li><a href="index.html#projects">Projets</a></li>
                        <li><a href="index.html#contact">Contact</a></li>
                    </ul>
                </div>
                
                <div class="footer-social">
                    <h3>Me suivre</h3>
                    <div class="social-icons">
                        <a href="https://github.com/aurelien-loyer" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/aurelien-loyer-epi/" target="_blank">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="mailto:aurelien.loyer@epitech.eu">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>© 2025 Aurélien Loyer. Tous droits réservés.</p>
                <a href="#" class="back-to-top">
                    <i class="fas fa-arrow-up"></i>
                </a>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script>
        // Variables pour le terminal interactif
        const terminalContent = document.getElementById('terminalContent');
        const launchShellBtn = document.getElementById('launchShellBtn');
        const promptContainer = document.getElementById('promptContainer');
        const commandInput = document.getElementById('commandInput');
        const prompt = document.getElementById('prompt');

        // État du shell
        let shellRunning = false;
        let currentDirectory = "~/mysh";
        let envVariables = {
            "HOME": "~/mysh",
            "PATH": "/usr/local/bin:/usr/bin:/bin",
            "USER": "user",
            "PWD": "~/mysh",
            "SHELL": "~/mysh/mysh",
            "TERM": "xterm-256color",
            "LANG": "fr_FR.UTF-8"
        };

        // Structure de fichiers simulée avec plus de contenu
        const fileSystem = {
            "~/mysh": {
                type: "directory",
                contents: {
                    "README.md": {
                        type: "file",
                        content: "# Mini Shell\n\nShell simplifié en langage C\n\n## Compilation\n\n```\nmake\n```\n\n## Utilisation\n\n```\n./mysh\n```\n\n## Fonctionnalités\n\n- Exécution de commandes externes\n- Gestion des commandes intégrées (cd, exit, env, setenv, unsetenv)\n- Support des variables d'environnement\n- Gestion du répertoire courant"
                    },
                    "src": {
                        type: "directory",
                        contents: {
                            "main.c": {
                                type: "file",
                                content: "#include \"../include/mysh.h\"\n\nint main(int argc, char **argv, char **env) {\n    // Initialize environment\n    char **env_copy = copy_environment(env);\n    \n    // Start command loop\n    run_shell(env_copy);\n    \n    // Clean up before exit\n    free_environment(env_copy);\n    return 0;\n}"
                            },
                            "builtins.c": {
                                type: "file",
                                content: "#include \"../include/builtins.h\"\n\nvoid builtin_cd(char **args, char **env) {\n    // Implementation of cd command\n    if (args[1] == NULL) {\n        chdir(getenv(\"HOME\"));\n    } else {\n        if (chdir(args[1]) != 0) {\n            fprintf(stderr, \"cd: %s: No such file or directory\\n\", args[1]);\n        }\n    }\n}\n\nvoid builtin_exit(char **args, char **env) {\n    // Implementation of exit command\n    int status = 0;\n    if (args[1] != NULL) {\n        status = atoi(args[1]);\n    }\n    free_args(args);\n    free_environment(env);\n    exit(status);\n}\n\nvoid builtin_env(char **args, char **env) {\n    // Implementation of env command\n    int i = 0;\n    while (env[i] != NULL) {\n        printf(\"%s\\n\", env[i]);\n        i++;\n    }\n}"
                            },
                            "execute.c": {
                                type: "file",
                                content: "#include \"../include/mysh.h\"\n\nvoid execute_command(char *command, char **env) {\n    // Parse command\n    char **args = parse_command(command);\n    \n    // Check if builtin\n    if (is_builtin(args[0])) {\n        execute_builtin(args, env);\n        free_args(args);\n        return;\n    }\n    \n    // Fork and execute\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        if (execvp(args[0], args) == -1) {\n            fprintf(stderr, \"%s: Command not found\\n\", args[0]);\n            exit(1);\n        }\n    } else if (pid > 0) {\n        // Parent process\n        int status;\n        waitpid(pid, &status, 0);\n    } else {\n        // Fork error\n        perror(\"fork\");\n    }\n    \n    free_args(args);\n}"
                            },
                            "env_manager.c": {
                                type: "file",
                                content: "#include \"../include/env_manager.h\"\n\nchar **copy_environment(char **env) {\n    int count = 0;\n    while (env[count] != NULL)\n        count++;\n    \n    char **env_copy = malloc(sizeof(char *) * (count + 1));\n    for (int i = 0; i < count; i++)\n        env_copy[i] = strdup(env[i]);\n    env_copy[count] = NULL;\n    \n    return env_copy;\n}\n\nvoid free_environment(char **env) {\n    if (env == NULL)\n        return;\n    \n    for (int i = 0; env[i] != NULL; i++) {\n        free(env[i]);\n    }\n    free(env);\n}\n\nchar *get_env_value(char **env, const char *name) {\n    int name_len = strlen(name);\n    int i = 0;\n    \n    while (env[i] != NULL) {\n        if (strncmp(env[i], name, name_len) == 0 && env[i][name_len] == '=') {\n            return env[i] + name_len + 1;\n        }\n        i++;\n    }\n    \n    return NULL;\n}"
                            },
                            "utils.c": {
                                type: "file",
                                content: "#include \"../include/mysh.h\"\n\nchar **parse_command(char *command) {\n    // Tokenize command by spaces\n    int max_tokens = 64;\n    char **tokens = malloc(sizeof(char *) * max_tokens);\n    char *token = strtok(command, \" \\t\\n\");\n    int pos = 0;\n    \n    while (token != NULL && pos < max_tokens - 1) {\n        tokens[pos++] = strdup(token);\n        token = strtok(NULL, \" \\t\\n\");\n    }\n    tokens[pos] = NULL;\n    return tokens;\n}\n\nint is_builtin(char *command) {\n    static const char *builtins[] = {\"cd\", \"exit\", \"env\", \"setenv\", \"unsetenv\", NULL};\n    \n    for (int i = 0; builtins[i] != NULL; i++) {\n        if (strcmp(command, builtins[i]) == 0) {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nvoid free_args(char **args) {\n    if (args == NULL)\n        return;\n    \n    for (int i = 0; args[i] != NULL; i++) {\n        free(args[i]);\n    }\n    free(args);\n}"
                            },
                            "shell.c": {
                                type: "file",
                                content: "#include \"../include/mysh.h\"\n\nvoid run_shell(char **env) {\n    char *line = NULL;\n    size_t len = 0;\n    ssize_t read;\n    \n    while (1) {\n        printf(\"%s $ \", get_env_value(env, \"PWD\"));\n        read = getline(&line, &len, stdin);\n        \n        if (read == -1) {\n            // EOF (Ctrl+D)\n            printf(\"exit\\n\");\n            break;\n        }\n        \n        // Remove trailing newline\n        if (line[read - 1] == '\\n') {\n            line[read - 1] = '\\0';\n        }\n        \n        // Skip empty lines\n        if (strlen(line) == 0) {\n            continue;\n        }\n        \n        // Execute the command\n        execute_command(line, env);\n    }\n    \n    free(line);\n}"
                            }
                        }
                    },
                    "include": {
                        type: "directory",
                        contents: {
                            "mysh.h": {
                                type: "file",
                                content: "#ifndef MYSH_H\n#define MYSH_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n// Shell functions\nvoid run_shell(char **env);\nvoid execute_command(char *command, char **env);\nchar **parse_command(char *command);\n\n// Builtin functions\nint is_builtin(char *command);\nvoid execute_builtin(char **args, char **env);\n\n// Environment management\nchar **copy_environment(char **env);\nvoid free_environment(char **env);\n\n// Memory management\nvoid free_args(char **args);\n\n#endif"
                            },
                            "builtins.h": {
                                type: "file",
                                content: "#ifndef BUILTINS_H\n#define BUILTINS_H\n\n#include \"mysh.h\"\n\n// Builtin commands\nvoid builtin_cd(char **args, char **env);\nvoid builtin_exit(char **args, char **env);\nvoid builtin_env(char **args, char **env);\nvoid builtin_setenv(char **args, char **env);\nvoid builtin_unsetenv(char **args, char **env);\n\n#endif"
                            },
                            "env_manager.h": {
                                type: "file",
                                content: "#ifndef ENV_MANAGER_H\n#define ENV_MANAGER_H\n\n#include \"mysh.h\"\n\n// Environment variable functions\nchar **copy_environment(char **env);\nvoid free_environment(char **env);\nchar *get_env_value(char **env, const char *name);\nvoid set_env_value(char ***env, const char *name, const char *value);\nvoid unset_env_value(char ***env, const char *name);\n\n#endif"
                            }
                        }
                    },
                    "tests": {
                        type: "directory",
                        contents: {
                            "test_builtins.c": {
                                type: "file",
                                content: "#include <criterion/criterion.h>\n#include \"../include/builtins.h\"\n\nTest(builtins, is_builtin) {\n    cr_assert(is_builtin(\"cd\"));\n    cr_assert(is_builtin(\"exit\"));\n    cr_assert(is_builtin(\"env\"));\n    cr_assert(is_builtin(\"setenv\"));\n    cr_assert(is_builtin(\"unsetenv\"));\n    cr_assert_not(is_builtin(\"ls\"));\n    cr_assert_not(is_builtin(\"cat\"));\n}"
                            },
                            "test_env.c": {
                                type: "file",
                                content: "#include <criterion/criterion.h>\n#include \"../include/env_manager.h\"\n\nTest(env, get_env_value) {\n    char *env[] = {\"HOME=/home/user\", \"PATH=/usr/bin\", NULL};\n    \n    cr_assert_str_eq(get_env_value(env, \"HOME\"), \"/home/user\");\n    cr_assert_str_eq(get_env_value(env, \"PATH\"), \"/usr/bin\");\n    cr_assert_null(get_env_value(env, \"USER\"));\n}"
                            }
                        }
                    },
                    "Makefile": {
                        type: "file",
                        content: "NAME = mysh\nSRC = src/main.c src/builtins.c src/execute.c src/env_manager.c src/utils.c src/shell.c\nOBJ = $(SRC:.c=.o)\nCFLAGS = -Wall -Wextra -I./include\n\nall: $(NAME)\n\n$(NAME): $(OBJ)\n\tgcc -o $(NAME) $(OBJ)\n\nclean:\n\trm -f $(OBJ)\n\nfclean: clean\n\trm -f $(NAME)\n\nre: fclean all\n\ntest: all\n\tgcc -o tests tests/*.c $(OBJ) -lcriterion\n\n.PHONY: all clean fclean re test"
                    },
                    ".gitignore": {
                        type: "file",
                        content: "# Object files\n*.o\n\n# Executable\nmysh\n\n# Temporary files\n*~\n.*.swp\n\n# Debug files\n*.dSYM/\n"
                    },
                    "mysh": {
                        type: "file",
                        content: "#!/bin/bash\n# Fichier executable simulé"
                    }
                }
            }
        };

        // Fonctions utilitaires pour naviguer dans le système de fichiers
        function getPath(path) {
            if (path.startsWith("~")) {
                path = path.replace("~", "~/mysh");
            }
            return path;
        }

        function resolvePath(basePath, targetPath) {
            if (targetPath.startsWith("/") || targetPath.startsWith("~")) {
                return getPath(targetPath);
            }
            
            const base = basePath.split("/");
            const parts = targetPath.split("/");
            
            for (const part of parts) {
                if (part === "..") {
                    if (base.length > 1) base.pop();
                } else if (part !== "." && part !== "") {
                    base.push(part);
                }
            }
            
            return base.join("/");
        }

        function getFileOrDir(path) {
            path = getPath(path);
            const parts = path.split("/");
            let current = fileSystem;
            
            for (let i = 0; i < parts.length; i++) {
                if (parts[i] === "" || parts[i] === "~") continue;
                
                if (!current[parts.slice(0, i+1).join("/")]) {
                    return null;
                }
                current = current[parts.slice(0, i+1).join("/")];
            }
            
            return current;
        }

        // Historique des commandes et autocomplétion
        let commandHistory = [];
        let historyIndex = -1;
        let autoCompleteIndex = -1;
        let autoCompleteMatches = [];

        // Commandes disponibles pour la simulation avec améliorations
        const availableCommands = {
            "ls": (args) => {
                let path = currentDirectory;
                let showHidden = false;
                let longFormat = false;
                let colorOutput = true;
                
                if (args) {
                    const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                    argsList.forEach(arg => {
                        if (arg.startsWith("-")) {
                            if (arg.includes("a")) showHidden = true;
                            if (arg.includes("l")) longFormat = true;
                            if (arg.includes("--color=none")) colorOutput = false;
                        } else if (arg) {
                            path = resolvePath(currentDirectory, arg);
                        }
                    });
                }
                
                const dir = getFileOrDir(path);
                if (!dir || dir.type !== "directory") {
                    return `ls: cannot access '${path}': No such file or directory`;
                }
                
                let result = [];
                const items = Object.keys(dir.contents);
                
                // Trier les entrées (dossiers d'abord, puis fichiers)
                items.sort((a, b) => {
                    const itemA = dir.contents[a];
                    const itemB = dir.contents[b];
                    if (itemA.type === "directory" && itemB.type !== "directory") return -1;
                    if (itemA.type !== "directory" && itemB.type === "directory") return 1;
                    return a.localeCompare(b);
                });
                
                items.forEach(key => {
                    const item = dir.contents[key];
                    if (!key.startsWith(".") || showHidden) {
                        if (longFormat) {
                            const permissions = item.type === "directory" ? "drwxr-xr-x" : "-rw-r--r--";
                            const size = item.type === "file" ? (item.content ? item.content.length : 100) : 4096;
                            const date = new Date().toLocaleString("fr-FR", { 
                                month: "short", 
                                day: "numeric", 
                                hour: "2-digit", 
                                minute: "2-digit" 
                            });
                            let displayName = key;
                            if (colorOutput) {
                                displayName = item.type === "directory" ? 
                                    `<span style="color: #4495ff;">${key}/</span>` : 
                                    `<span style="color: #ffffff;">${key}</span>`;
                            } else {
                                displayName = item.type === "directory" ? `${key}/` : key;
                            }
                            result.push(`${permissions} 1 user user ${size.toString().padStart(5)} ${date} ${displayName}`);
                        } else {
                            if (colorOutput) {
                                if (item.type === "directory") {
                                    result.push(`<span style="color: #4495ff;">${key}/</span>`);
                                } else if (key.endsWith(".c") || key.endsWith(".h")) {
                                    result.push(`<span style="color: #50fa7b;">${key}</span>`);
                                } else if (key === "Makefile") {
                                    result.push(`<span style="color: #ff79c6;">${key}</span>`);
                                } else if (key.startsWith(".")) {
                                    result.push(`<span style="color: #8a8a8a;">${key}</span>`);
                                } else {
                                    result.push(`<span style="color: #ffffff;">${key}</span>`);
                                }
                            } else {
                                result.push(`${key}${item.type === "directory" ? "/" : ""}`);
                            }
                        }
                    }
                });
                
                return result.join("  ");
            },
            "pwd": () => currentDirectory,
            "cd": (args) => {
                let targetPath;
                
                if (!args || args === "~" || args === "") {
                    targetPath = "~/mysh";
                } else {
                    targetPath = resolvePath(currentDirectory, args);
                }
                
                const dir = getFileOrDir(targetPath);
                if (!dir) {
                    return `cd: ${args}: No such file or directory`;
                }
                
                if (dir.type !== "directory") {
                    return `cd: ${args}: Not a directory`;
                }
                
                currentDirectory = targetPath;
                envVariables["PWD"] = currentDirectory;
                updatePrompt();
                return "";
            },
            "cat": (args) => {
                if (!args) {
                    return "cat: missing operand";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                let result = [];
                
                for (const arg of argsList) {
                    const path = resolvePath(currentDirectory, arg);
                    const file = getFileOrDir(path);
                    
                    if (!file) {
                        result.push(`cat: ${arg}: No such file or directory`);
                        continue;
                    }
                    
                    if (file.type !== "file") {
                        result.push(`cat: ${arg}: Is a directory`);
                        continue;
                    }
                    
                    result.push(file.content);
                }
                
                return result.join("\n");
            },
            "echo": (args) => {
                if (!args) return "";
                
                // Gestion des variables d'environnement
                let result = args;
                const envVarMatches = args.match(/\$([A-Za-z_][A-Za-z0-9_]*)/g);
                
                if (envVarMatches) {
                    envVarMatches.forEach(match => {
                        const varName = match.substring(1);
                        if (envVariables[varName]) {
                            result = result.replace(match, envVariables[varName]);
                        } else {
                            result = result.replace(match, "");
                        }
                    });
                }
                
                return result;
            },
            "env": () => {
                let result = [];
                Object.keys(envVariables).forEach(key => {
                    result.push(`${key}=${envVariables[key]}`);
                });
                return result.join("\n");
            },
            "setenv": (args) => {
                if (!args) {
                    return availableCommands["env"]();
                }
                
                const parts = args.split(/\s+/).filter(part => part.length > 0);
                if (parts.length < 2) {
                    return "setenv: Too few arguments.";
                }
                
                // Vérification du format du nom de variable
                if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(parts[0])) {
                    return `setenv: Variable name '${parts[0]}' must contain alphanumeric characters.`;
                }
                
                envVariables[parts[0]] = parts[1];
                return "";
            },
            "unsetenv": (args) => {
                if (!args) {
                    return "unsetenv: Too few arguments.";
                }
                
                const varNames = args.split(/\s+/).filter(name => name.length > 0);
                let error = false;
                
                for (const varName of varNames) {
                    if (envVariables[varName]) {
                        delete envVariables[varName];
                    } else {
                        error = true;
                    }
                }
                
                return error ? `unsetenv: Variable(s) not found.` : "";
            },
            "grep": (args) => {
                if (!args) {
                    return "grep: missing pattern";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                if (argsList.length < 2) {
                    return "grep: missing file operand";
                }
                
                const pattern = argsList[0];
                let colorize = false;
                let showLineNumbers = false;
                let invertMatch = false;
                let fileArgs = [];
                
                // Analyse des options
                for (let i = 1; i < argsList.length; i++) {
                    if (argsList[i].startsWith("-")) {
                        if (argsList[i].includes("n")) showLineNumbers = true;
                        if (argsList[i].includes("v")) invertMatch = true;
                        if (argsList[i].includes("--color")) colorize = true;
                    } else {
                        fileArgs.push(argsList[i]);
                    }
                }
                
                if (fileArgs.length === 0) {
                    return "grep: missing file operand";
                }
                
                let results = [];
                
                for (const fileArg of fileArgs) {
                    const path = resolvePath(currentDirectory, fileArg);
                    const file = getFileOrDir(path);
                    
                    if (!file) {
                        results.push(`grep: ${fileArg}: No such file or directory`);
                        continue;
                    }
                    
                    if (file.type !== "file") {
                        results.push(`grep: ${fileArg}: Is a directory`);
                        continue;
                    }
                    
                    const lines = file.content.split("\n");
                    let matchCount = 0;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const matches = line.match(new RegExp(pattern, "g"));
                        const hasMatch = matches !== null;
                        
                        if ((hasMatch && !invertMatch) || (!hasMatch && invertMatch)) {
                            matchCount++;
                            let result = "";
                            
                            if (fileArgs.length > 1) {
                                result += `${fileArg}:`;
                            }
                            
                            if (showLineNumbers) {
                                result += `${i + 1}:`;
                            }
                            
                            if (colorize && hasMatch && !invertMatch) {
                                let coloredLine = line;
                                for (const match of matches) {
                                    coloredLine = coloredLine.replace(
                                        match, 
                                        `<span style="color: #ff5555; font-weight: bold;">${match}</span>`
                                    );
                                }
                                result += coloredLine;
                            } else {
                                result += line;
                            }
                            
                            results.push(result);
                        }
                    }
                    
                    if (matchCount === 0 && fileArgs.length > 1) {
                        results.push(`grep: ${fileArg}: No matches found`);
                    }
                }
                
                return results.join("\n");
            },
            "find": (args) => {
                if (!args) {
                    return "find: missing path operand";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                let path = currentDirectory;
                let namePattern = null;
                let typeFilter = null;
                
                // Analyser les arguments
                for (let i = 0; i < argsList.length; i++) {
                    if (i === 0 && !argsList[i].startsWith("-")) {
                        path = resolvePath(currentDirectory, argsList[i]);
                    } else if (argsList[i] === "-name" && i+1 < argsList.length) {
                        namePattern = argsList[++i].replace(/\*/g, ".*").replace(/\?/g, ".");
                    } else if (argsList[i] === "-type" && i+1 < argsList.length) {
                        typeFilter = argsList[++i] === "d" ? "directory" : "file";
                    }
                }
                
                const dir = getFileOrDir(path);
                if (!dir) {
                    return `find: '${path}': No such file or directory`;
                }
                
                const results = [];
                
                // Fonction récursive pour explorer les répertoires
                function findInDirectory(currentPath, dir) {
                    for (const [name, item] of Object.entries(dir.contents)) {
                        const itemPath = `${currentPath}/${name}`;
                        
                        let matchesName = true;
                        if (namePattern) {
                            matchesName = new RegExp("^" + namePattern + "$").test(name);
                        }
                        
                        let matchesType = true;
                        if (typeFilter) {
                            matchesType = item.type === typeFilter;
                        }
                        
                        if (matchesName && matchesType) {
                            results.push(itemPath);
                        }
                        
                        if (item.type === "directory") {
                            findInDirectory(itemPath, item);
                        }
                    }
                }
                
                if (dir.type === "directory") {
                    // Commencer par le répertoire de base
                    if ((!typeFilter || typeFilter === "directory") && 
                        (!namePattern || new RegExp("^" + namePattern + "$").test(path.split("/").pop()))) {
                        results.push(path);
                    }
                    findInDirectory(path, dir.contents);
                } else {
                    if ((!typeFilter || typeFilter === "file") && 
                        (!namePattern || new RegExp("^" + namePattern + "$").test(path.split("/").pop()))) {
                        results.push(path);
                    }
                }
                
                return results.join("\n");
            },
            "head": (args) => {
                if (!args) {
                    return "head: missing file operand";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                let lineCount = 10;
                let fileArgs = [];
                
                // Analyser les options
                for (let i = 0; i < argsList.length; i++) {
                    if (argsList[i] === "-n" && i+1 < argsList.length) {
                        lineCount = parseInt(argsList[++i]);
                        if (isNaN(lineCount) || lineCount < 1) {
                            return `head: invalid number of lines: '${argsList[i]}'`;
                        }
                    } else if (!argsList[i].startsWith("-")) {
                        fileArgs.push(argsList[i]);
                    }
                }
                
                if (fileArgs.length === 0) {
                    return "head: missing file operand";
                }
                
                let results = [];
                
                for (const fileArg of fileArgs) {
                    const path = resolvePath(currentDirectory, fileArg);
                    const file = getFileOrDir(path);
                    
                    if (!file) {
                        results.push(`head: ${fileArg}: No such file or directory`);
                        continue;
                    }
                    
                    if (file.type !== "file") {
                        results.push(`head: ${fileArg}: Is a directory`);
                        continue;
                    }
                    
                    if (fileArgs.length > 1) {
                        results.push(`==> ${fileArg} <==`);
                    }
                    
                    const lines = file.content.split("\n");
                    results.push(lines.slice(0, lineCount).join("\n"));
                }
                
                return results.join("\n\n");
            },
            "tail": (args) => {
                if (!args) {
                    return "tail: missing file operand";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                let lineCount = 10;
                let fileArgs = [];
                
                // Analyser les options
                for (let i = 0; i < argsList.length; i++) {
                    if (argsList[i] === "-n" && i+1 < argsList.length) {
                        lineCount = parseInt(argsList[++i]);
                        if (isNaN(lineCount) || lineCount < 1) {
                            return `tail: invalid number of lines: '${argsList[i]}'`;
                        }
                    } else if (!argsList[i].startsWith("-")) {
                        fileArgs.push(argsList[i]);
                    }
                }
                
                if (fileArgs.length === 0) {
                    return "tail: missing file operand";
                }
                
                let results = [];
                
                for (const fileArg of fileArgs) {
                    const path = resolvePath(currentDirectory, fileArg);
                    const file = getFileOrDir(path);
                    
                    if (!file) {
                        results.push(`tail: ${fileArg}: No such file or directory`);
                        continue;
                    }
                    
                    if (file.type !== "file") {
                        results.push(`tail: ${fileArg}: Is a directory`);
                        continue;
                    }
                    
                    if (fileArgs.length > 1) {
                        results.push(`==> ${fileArg} <==`);
                    }
                    
                    const lines = file.content.split("\n");
                    results.push(lines.slice(-lineCount).join("\n"));
                }
                
                return results.join("\n\n");
            },
            "wc": (args) => {
                if (!args) {
                    return "wc: missing file operand";
                }
                
                const argsList = args.split(/\s+/).filter(arg => arg.length > 0);
                let countLines = true;
                let countWords = true;
                let countBytes = true;
                let fileArgs = [];
                
                // Analyser les options
                for (let i = 0; i < argsList.length; i++) {
                    if (argsList[i].startsWith("-")) {
                        if (argsList[i].includes("l")) {
                            countWords = false;
                            countBytes = false;
                        }
                        if (argsList[i].includes("w")) {
                            countLines = false;
                            countBytes = false;
                        }
                        if (argsList[i].includes("c")) {
                            countLines = false;
                            countWords = false;
                        }
                    } else {
                        fileArgs.push(argsList[i]);
                    }
                }
                
                if (fileArgs.length === 0) {
                    return "wc: missing file operand";
                }
                
                let results = [];
                let totalLines = 0;
                let totalWords = 0;
                let totalBytes = 0;
                
                for (const fileArg of fileArgs) {
                    const path = resolvePath(currentDirectory, fileArg);
                    const file = getFileOrDir(path);
                    
                    if (!file) {
                        results.push(`wc: ${fileArg}: No such file or directory`);
                        continue;
                    }
                    
                    if (file.type !== "file") {
                        results.push(`wc: ${fileArg}: Is a directory`);
                        continue;
                    }
                    
                    const content = file.content;
                    const lines = content.split("\n").length;
                    const words = content.split(/\s+/).filter(word => word.length > 0).length;
                    const bytes = content.length;
                    
                    let result = "";
                    if (countLines) {
                        result += `${lines.toString().padStart(7)} `;
                        totalLines += lines;
                    }
                    if (countWords) {
                        result += `${words.toString().padStart(7)} `;
                        totalWords += words;
                    }
                    if (countBytes) {
                        result += `${bytes.toString().padStart(7)} `;
                        totalBytes += bytes;
                    }
                    
                    result += fileArg;
                    results.push(result);
                }
                
                // Ajouter le total si plus d'un fichier
                if (fileArgs.length > 1) {
                    let totalResult = "";
                    if (countLines) {
                        totalResult += `${totalLines.toString().padStart(7)} `;
                    }
                    if (countWords) {
                        totalResult += `${totalWords.toString().padStart(7)} `;
                    }
                    if (countBytes) {
                        totalResult += `${totalBytes.toString().padStart(7)} `;
                    }
                    
                    totalResult += "total";
                    results.push(totalResult);
                }
                
                return results.join("\n");
            },
            "clear": () => {
                terminalContent.innerHTML = "";
                return "";
            },
            "help": () => {
                return "Commandes disponibles :\n" +
                    "  ls [options] [chemin]      - Lister le contenu d'un répertoire\n" +
                    "  cd [chemin]                - Changer de répertoire\n" +
                    "  pwd                        - Afficher le répertoire courant\n" +
                    "  cat [fichier(s)]           - Afficher le contenu d'un fichier\n" +
                    "  echo [texte]               - Afficher du texte\n" +
                    "  env                        - Afficher les variables d'environnement\n" +
                    "  setenv [nom] [valeur]      - Définir une variable d'environnement\n" +
                    "  unsetenv [nom(s)]          - Supprimer une variable d'environnement\n" +
                    "  grep [motif] [fichier(s)]  - Rechercher un motif dans des fichiers\n" +
                    "  find [chemin] [options]    - Rechercher des fichiers\n" +
                    "  head [options] [fichier(s)]- Afficher le début des fichiers\n" +
                    "  tail [options] [fichier(s)]- Afficher la fin des fichiers\n" +
                    "  wc [options] [fichier(s)]  - Compter les lignes, mots et octets\n" +
                    "  clear                      - Effacer le contenu du terminal\n" +
                    "  make [cible]               - Exécuter les cibles du Makefile\n" +
                    "  help                       - Afficher cette aide\n" +
                    "  exit                       - Quitter le shell";
            },
            "make": (args) => {
                const makeFilePath = resolvePath(currentDirectory, "Makefile");
                const makeFile = getFileOrDir(makeFilePath);
                
                if (!makeFile || makeFile.type !== "file") {
                    return "make: Makefile not found. Stop.";
                }
                
                const target = args ? args.split(/\s+/)[0] : "all";
                
                if (target === "all") {
                    return "gcc -o mysh src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o\ncc    -Wall -Wextra -I./include   -c -o src/main.o src/main.c\ncc    -Wall -Wextra -I./include   -c -o src/builtins.o src/builtins.c\ncc    -Wall -Wextra -I./include   -c -o src/execute.o src/execute.c\ncc    -Wall -Wextra -I./include   -c -o src/env_manager.o src/env_manager.c\ncc    -Wall -Wextra -I./include   -c -o src/utils.o src/utils.c\ncc    -Wall -Wextra -I./include   -c -o src/shell.o src/shell.c";
                } else if (target === "clean") {
                    return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o";
                } else if (target === "fclean") {
                    return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o\nrm -f mysh";
                } else if (target === "re") {
                    return "rm -f src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o\nrm -f mysh\ngcc -o mysh src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o\ncc    -Wall -Wextra -I./include   -c -o src/main.o src/main.c\ncc    -Wall -Wextra -I./include   -c -o src/builtins.o src/builtins.c\ncc    -Wall -Wextra -I./include   -c -o src/execute.o src/execute.c\ncc    -Wall -Wextra -I./include   -c -o src/env_manager.o src/env_manager.c\ncc    -Wall -Wextra -I./include   -c -o src/utils.o src/utils.c\ncc    -Wall -Wextra -I./include   -c -o src/shell.o src/shell.c";
                } else if (target === "test") {
                    return "gcc -o tests tests/*.c src/main.o src/builtins.o src/execute.o src/env_manager.o src/utils.o src/shell.o -lcriterion\nRunning tests...\n[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0";
                } else {
                    return `make: *** No rule to make target '${target}'. Stop.`;
                }
            },
            "exit": () => {
                shellRunning = false;
                updatePrompt();
                return "Shell terminated.";
            }
        };

        // Fonction pour mettre à jour le prompt
        function updatePrompt() {
            const promptUser = envVariables["USER"] || "user";
            const displayPath = currentDirectory.replace("~/mysh", "~");
            
            if (shellRunning) {
                prompt.innerHTML = `<span style="color: #50fa7b;">${promptUser}@mysh</span>:<span style="color: #4495ff;">${displayPath}</span>$ `;
                promptContainer.style.display = "flex";
            } else {
                promptContainer.style.display = "none";
            }
        }

        // Fonction pour traiter les commandes
        function processCommand(command) {
            // Ajouter à l'historique et réinitialiser l'index
            if (command.trim()) {
                commandHistory.push(command);
                historyIndex = -1;
            }
            
            const displayCommand = document.createElement("div");
            displayCommand.innerHTML = `<span style="color: #50fa7b;">${envVariables["USER"]}@mysh</span>:<span style="color: #4495ff;">${currentDirectory.replace("~/mysh", "~")}</span>$ ${command}`;
            terminalContent.appendChild(displayCommand);
            
            // Traitement des pipes et redirections (basique)
            if (command.includes("|") || command.includes(">") || command.includes("<")) {
                const errorElement = document.createElement("div");
                errorElement.textContent = "Pipes et redirections ne sont pas encore implémentés dans cette démo simplifiée.";
                errorElement.style.color = "#ff5555";
                terminalContent.appendChild(errorElement);
                return;
            }
            
            // Traitement des commandes séparées par des points-virgules
            if (command.includes(";")) {
                const commands = command.split(";");
                for (const cmd of commands) {
                    processCommand(cmd.trim());
                }
                return;
            }
            
            let [cmdName, ...args] = command.trim().split(/\s+/);
            const cmdArgs = args.join(" ");
            
            if (cmdName in availableCommands) {
                const output = availableCommands[cmdName](cmdArgs);
                
                if (output) {
                    const outputElement = document.createElement("div");
                    outputElement.innerHTML = output;
                    terminalContent.appendChild(outputElement);
                }
            } else if (cmdName) {
                const errorElement = document.createElement("div");
                errorElement.textContent = `${cmdName}: command not found`;
                errorElement.style.color = "#ff5555";
                terminalContent.appendChild(errorElement);
            }
            
            // Faire défiler vers le bas
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }

        // Gestionnaire d'événements pour le bouton de lancement du shell
        launchShellBtn.addEventListener('click', function() {
            shellRunning = true;
            updatePrompt();
            const welcomeMsg = document.createElement("div");
            welcomeMsg.innerHTML = `
            <pre style="color: #50fa7b;">
            __  __ ___ ___ _  _ 
            |  \\/  |_ _| _ \\ || |
            | |\\/| || ||   / __ |
            |_|  |_|___|_|_\\_||_|
            </pre>
            <p>Bienvenue dans le Mini Shell Interactif (mysh)</p>
            <p>Type 'help' for available commands</p>
            `;
            terminalContent.innerHTML = "";
            terminalContent.appendChild(welcomeMsg);
            commandInput.focus();
        });

        // Gestionnaire d'événements pour l'entrée de commande
        commandInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const command = commandInput.value.trim();
                processCommand(command);
                commandInput.value = "";
                autoCompleteIndex = -1;
                autoCompleteMatches = [];
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0) {
                    historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
                    commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
                } else {
                    historyIndex = -1;
                    commandInput.value = "";
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                
                // Autocomplétion
                const input = commandInput.value;
                const lastWord = input.split(/\s+/).pop();
                
                if (autoCompleteIndex === -1) {
                    // Première pression de Tab, rechercher les correspondances
                    if (input.split(/\s+/).length === 1) {
                        // Autocomplétion de commande
                        autoCompleteMatches = Object.keys(availableCommands).filter(cmd => 
                            cmd.startsWith(lastWord)
                        );
                    } else {
                        // Autocomplétion de chemin
                        const dir = getFileOrDir(currentDirectory);
                        if (dir && dir.type === "directory") {
                            autoCompleteMatches = Object.keys(dir.contents).filter(item => 
                                item.startsWith(lastWord)
                            );
                        }
                    }
                    
                    autoCompleteIndex = 0;
                } else {
                    // Pressions suivantes de Tab, parcourir les correspondances
                    autoCompleteIndex = (autoCompleteIndex + 1) % autoCompleteMatches.length;
                }
                
                if (autoCompleteMatches.length > 0) {
                    const match = autoCompleteMatches[autoCompleteIndex];
                    const inputParts = input.split(/\s+/);
                    inputParts.pop();
                    inputParts.push(match);
                    commandInput.value = inputParts.join(" ");
                }
            } else {
                // Réinitialiser l'autocomplétion si l'utilisateur tape quelque chose
                autoCompleteIndex = -1;
                autoCompleteMatches = [];
            }
        });

        // Initialisation
        updatePrompt();
    </script>
</body>
</html>
